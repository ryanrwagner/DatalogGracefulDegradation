#compromiseCombo,pathCompromisesWithCostCombo,Combo
#+ compromiseCombo([])
#compromiseCombo(Y) <= compromiseCombo(X) & compromised(TargetService) & TargetService._not_in(X) & (Y == X + [TargetService])

#pathCompromisesWithCostCombo(X,TotalC,Combo) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) & (X == [SourceService,TargetService,P,E]) & (Y._in(Combo)) & (Y._in(E))

# (X == [SourceService,TargetService,P,E])
#(worstCasePathCombo[TotalC,Combo] == max_(UtilPathPair, order_by=U)) <= pathCompromisesWithCost(X,C) & (pathCompromisesUtilities[X] == U) & (pathCompromisesFunctions[X] == FList) & (UtilPathPair==[U,FList,X,Combo]) & (TotalC >= C) & (X == [SourceService,TargetService,P,E]) & (Y._in(Combo)) & (Y._in(E))

#New codespace
#ASKED
#What is the worst case attack path for a given attacker capability?
#TotalC is the given attacker capability
#We find all the paths that exist for a given capability C that is <= TotalC
#Then we choose the max (worst)
# (X == [SourceService,TargetService,P,E])
#Changed on 20230321
#(worstCasePath[TotalC] == max_(UtilPathPair, order_by=U)) <= pathCompromisesWithCost(X,C) & (pathCompromisesUtilities[X] == U) & (pathCompromisesFunctions[X] == FList) & (UtilPathPair==[U,FList,X]) & (TotalC >= C) #& (TotalC <= MaxR)
(worstCasePath[C] == max_(UtilPathPair, order_by=U)) <= pathCompromisesWithCost(X,C) & (pathCompromisesUtilities[X] == U) & (pathCompromisesFunctions[X] == FList) & (UtilPathPair==[U,FList,X]) #& (TotalC >= C) #& (TotalC <= MaxR)

#(worstCasePathSpecific[TotalC,Y] == max_(UtilPathPair, order_by=U)) <= pathCompromisesWithCost(X,C) & (pathCompromisesUtilities[X] == U) & (pathCompromisesFunctions[X] == FList) & (UtilPathPair==[U,FList,X]) & (TotalC >= C) & (X == [SourceService,TargetService,P,E]) & (Y._in(E)) & compromised(Y)

#worstCasePaths(TotalC) <= worstCasePath(TotalC) & (TotalC <= MaxR)

#BUG Fix this
MaxR=4

#ASKED
#weightedWorstCasePath[TotalC] = probCapability[TotalC] * worstCasePathValue[TotalC]
#weightedWorstCasePath[TotalC] = probCapability(TotalC,p) * worstCasePathValue[TotalC]
#Note that this is the worst case path for any path of exactly capability C, not up to and including C
(worstCasePathUtil[C] == max_(UtilPathPair, order_by=U)) <= pathCompromisesWithCost(X,C) & (pathCompromisesUtilities[X] == U) & (pathCompromisesFunctions[X] == FList) & (UtilPathPair==[U,FList,X]) #& (TotalC >= C) #& (TotalC <= MaxR)
#(worstCasePathUtil[C,U] == max_(UtilPathPair, order_by=U)) <= pathCompromisesWithCost(X,C) & (pathCompromisesUtilities[X] == U) & (pathCompromisesFunctions[X] == FList) & (UtilPathPair==[U,FList,X]) #& (TotalC >= C) #& (TotalC <= MaxR)
#(worstCasePathUtil[C,U] == max_(UtilPathPair, order_by=U)) <= pathCompromisesWithCost(X,C) & (pathCompromisesUtilities[X] == U) & (pathCompromisesFunctions[X] == FList) & (UtilPathPair==[U,FList,X]) #& (TotalC >= C) #& (TotalC <= MaxR)

#BUG TODO Next: This is wrong and the weightedWorstCasePath should use this value instead of worstCasePathUtil
#Note that this is the worst case for any path up to and including the given capability C, not just a path of exactly C
#(worstCasePathUtilInclusive[C,U] == max_(UtilPathPair, order_by=U)) <= (worstCasePathUtil[C,U] == UtilPathPair)
(worstCasePathUtilInclusive[C] == max_(UtilPathPair, order_by=U)) <= (worstCasePathUtil[C2] == UtilPathPair) & (probCapability[C] == PC) & (C2 <= C) & (UtilPathPair==[U,FList,X])  #& ~(worstCasePathUtil[C2,U2] == Y2) & (C2 < C) & (U2 > U)
#(worstCasePathUtilInclusive[C] == max_(UtilPathPair, order_by=U)) <= (worstCasePathUtil[C2,U] == UtilPathPair) & (probCapability[C] == PC) & (C2 <= C)  #& ~(worstCasePathUtil[C2,U2] == Y2) & (C2 < C) & (U2 > U)

#wcp(0,0) == foo
#wcp(1,10) == foo2
#wcp(2,10) == foo3
#wcp(3,110) == foo4

#'worstCasePathUtil[C,U] == Y'
#[(3,
#  110,
#  (110,
#   'attackerFunction,dataTransit,firewall',
#   ('attacker',
#    'server',
#    ('fwA2', 'fwA2', 'fwB2'),
#    ('fwAExploit', 'fwBExploit', 'serverExploit')))),
# (2,
#  10,
#  (10,
#   'attackerFunction,firewall',
#   ('attacker', 'fwB2', ('fwA2', 'fwA2'), ('fwAExploit', 'fwBExploit')))),
# (1,
#  10,
#  (10,
#   'attackerFunction,firewall',
#   ('attacker', 'fwA2', ('fwA2',), ('fwAExploit',)))),
# (0,
#  0,
#  (0, 'attackerFunction', ('attacker', 'attacker', (), ('compromised',))))]

#(weightedWorstCasePath[C] == U2) <= (worstCasePathUtil[C,U] == Y) & (probCapability[C] == PC) & (U2 == PC * U)
(weightedWorstCasePath[C] == U2) <= (worstCasePathUtilInclusive[C] == Y) & (Y==[U,FList,X]) & (probCapability[C] == PC) & (U2 == PC * U)


# TODO Next: This is the expected utility that is used by the attacker
# I need to make this so it's the remaining utility (sum the total utilities and take this off of it)
(residualUtility[0] == sum_(U2,for_each=C)) <= (weightedWorstCasePath[C] == U2) #& (C <= MaxR)



#What are the paths that exist at a particular cost?
pathCompromisesWithCost(X,TotalC) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC,CImpact,IImpact,AImpact) & (X == [SourceService,TargetService,P,E])

#What's the value of the compromised functions for a path?
#Running sum would be helpful?
#(P[X]==sum_(Y, for_each=Z)) <= body
(pathCompromisesUtilities[X] == sum_(U2,for_each=X)) <= pathCompromisesFunctionWithCost(X,FuncName,U2,TotalC)

(pathCompromisesFunctions[X] == concat_(FuncName,order_by=FuncName,sep=',')) <= pathCompromisesFunctionWithCost(X,FuncName,U2,TotalC)

#Base case special case for no capability
#attackPaths(SourceService,SourceService,P,[],0) <= compromised(SourceService) & (P==[])
#Base case
#attackPaths(SourceService,TargetService,P,[VulnType],TotalC) <= compromised(SourceService) & cToWithPrivileges(SourceService,TargetService,VulnType,TotalC) & (P==[]) & (TotalC <= MaxR)
#Inductive case, new exploit
#attackPaths(SourceService,TargetService,P,E,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,TotalC2) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (VulnType._not_in(E2)) & (E==E2+[VulnType]) & (TotalC==TotalC2+C) & (TotalC2+C <= MaxR)
#Inductive case, previously-used exploit
#attackPaths(SourceService,TargetService,P,E,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,TotalC2) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (VulnType._in(E2)) & (E==E2+[VulnType]) & (TotalC==TotalC2) & (TotalC2+C <= MaxR)

#New Version for Types:
#Note, now each component must have an associated type
#Assumption that the attacker exploits specifically for the component type and not for a component super type
#Base case special case for no capability
#attackPaths(SourceService,SourceService,P,[],0) <= compromised(SourceService) & (P==[])
#Base case
#attackPaths(SourceService,TargetService,P,[VulnType],TotalC) <= compromised(SourceService) & cToWithPrivileges(SourceService,TargetService,VulnType,TotalC) & (P==[]) & (TotalC <= MaxR) & isType(TargetService,ComponentType)
#Inductive case, new exploit
#attackPaths(SourceService,TargetService,P,E,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,TotalC2) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (VulnType._not_in(E2)) & (E==E2+[VulnType]) & (TotalC==TotalC2+C) & (TotalC2+C <= MaxR) & isType(TargetService,ComponentType)
#Inductive case, previously-used exploit
#attackPaths(SourceService,TargetService,P,E,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,TotalC2) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (VulnType._in(E2)) & (E==E2+[VulnType]) & (TotalC==TotalC2) & (TotalC2+C <= MaxR) & isType(TargetService,ComponentType)

#TODO Next...Still need to add the names to main.py

#Algorithm Discussion for when branching is added:
#First, we generate an attack path for a particular point of compromise and cost
#Then, we stitch together the attack paths to get the attack path combinations with a particular total cost
#For each attacker capability:
#And for each combination of possible compromises:
#We will find the worst case attack path
#We will take an estimated value that is the sum(probability(compromise set for that attack path) * utilityImpact(attack path))
#This allows us to consider when the attacker leverages multiple points of compromise at once.
#This really gets at the possibility that a system might have to fight two simultaneous attack (e.g., an outsider and an insider)

#Base case
#attackPathCombos(Compromises,Paths,TotalC) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC,CImpact,IImpact,AImpact)
#Inductive case
#attackPathCombos(Compromises,Paths,TotalC) <= attackPathCombos(Compromises2,Paths2,TotalC2) & (AP == attackPaths(SourceService,TargetService,P,E,AttackerMoves,C,CImpact,IImpact,AImpact)) & (AP._not_in(Paths2)) & (Compromises == Compromises2+[SourceService]) & (Paths == Paths2+[AP]) & (TotalC == TotalC2+C) & (TotalC2+C <= MaxR)

#Note: Sometimes, as we build a trace, we charge the cost for exploiting something "compromised" and sometimes don't, but always be consistent with the previous moves (in cases of branching), and returning through source is always free (in cases of branching). This way, we can generate in one shot all the traces for all possible combinations of compromises.
#What I need to change: I need to have two different types of exploit for compromised components. One is assuming compromise at initial state (so cost of exploit is zero), and the other is assume no compromise at initial state (so cost of exploit is non-zero).
#Then, I need to pull all the worst case scenarios based on each combo of compromises (represented in AttackerMoves) and reconstruct the numbers from there


#New with Types and Branching

# attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC,CImpact,IImpact,AImpact)
# There is an attack from the source to the target with the path P using the set of exploits E.
# AttackerMoves is a set of moves that the attacker has made so far [[ServiceA,ServiceB,VulnType],...]
# Then we have the total cost of the attack so far and the impacts on confidentiality, integrity, and availability

#TODO NEXT: Ensure all C,I,A stuff is in the attack paths
#TODO NEXT: Fix credential handling

#Base case for first compromised component
attackPaths(SourceService,SourceService,P,['compromised'],AttackerMoves,0,CImpact,IImpact,AImpact) <= compromised(SourceService,PC,CImpact,IImpact,AImpact) & (P==[]) & (AttackerMoves==[[SourceService,SourceService,'compromised']]) #& hasCredential(SourceService,Credential)
#Rewrite for better branch handling
#An attack path is [Source,Target,P]
#attackScenarioPiece(APSet,AttackerMoves,CumulativeP,E,Leaves,SourceService,TargetService,CurrentP,CompromiseSet,PC,TotalC)
attackScenarioPiece([],[[SourceService,SourceService,'compromised'+SourceService]],[SourceService],E,[],SourceService,SourceService,[SourceService],[SourceService],PC,0) <= compromised(SourceService,PC,CImpact,IImpact,AImpact) & hasCredentials(SourceService,CredentialSet) & (E == ['compromised'+SourceService]+CredentialSet)

#THOUGHTS
#Ordered list
#Maintain a list of prior paths
#Maintain a current path
#Maintain a history of all components visited and all points of compromise used (plus probability)
#When we branch, we add the current path to the list of prior paths
#Keep C,I,A with each path

#Base case to continue connectivity with novel exploit
#Note: Is this needed anymore given the above base case?
attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC,CImpact,IImpact,AImpact) <= compromised(SourceService,PC,CImpact2,IImpact2,AImpact2) & attackerConnectsTo(SourceService,TargetService,VulnType,TotalC,CImpact3,IImpact3,AImpact3) & (P==[TargetService]) & (E==['compromised'+SourceService,VulnType]) & (TotalC <= MaxR) & isType(TargetService,ComponentType) & (AttackerMoves==[[SourceService,TargetService,VulnType]]) & (CImpact==CImpact2*CImpact3) & (IImpact==IImpact2*IImpact3) & (AImpact==AImpact2*AImpact3) #& hasCredential(TargetService,Credential)
#Rewrite for better branch handling
#attackScenarioPiece(APSet,AttackerMoves,CumulativeP,E,Leaves,SourceService,TargetService,CurrentP,CompromiseSet,PC,TotalC)
attackScenarioPiece([],AttackerMoves,CumulativeP,E,[],SourceService,TargetService,CurrentP,CompromiseSet,PC,TotalC) <= compromised(SourceService,PC,CImpact2,IImpact2,AImpact2) & attackerConnectsTo(SourceService,TargetService,VulnType,TotalC,CImpact3,IImpact3,AImpact3) & (AttackerMoves == [[SourceService,SourceService,'compromised'+SourceService],[SourceService,TargetService,VulnType]]) & (CumulativeP == [SourceService,TargetService]) & hasCredentials(TargetService,CredentialSet) & (E == ['compromised'+SourceService,VulnType]+CredentialSet) & (CurrentP == [SourceService,TargetService]) & (CompromiseSet == [SourceService]) & (TotalC <= MaxR) 

#Inductive case to continue connectivity, novel exploit
attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC,CImpact,IImpact,AImpact) <= attackPaths(SourceService,IntermediateService1,P2,E2,AttackerMoves2,TotalC2,CImpact2,IImpact2,AImpact2) & attackerConnectsTo(IntermediateService1,TargetService,VulnType,C,CImpact3,IImpact3,AImpact3) & (P==P2+[IntermediateService1]) & (VulnType._not_in(E2)) & (E==E2+[VulnType]) & (TotalC==TotalC2+C) & (TotalC2+C <= MaxR) & (AttackerMove==[IntermediateService1,TargetService,VulnType]) & (AttackerMove._not_in(AttackerMoves2)) & (AttackerMoves==AttackerMoves2+[AttackerMove]) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (CImpact==CImpact2*CImpact3) & (IImpact==IImpact2*IImpact3) & (AImpact==AImpact2*AImpact3)
#Rewrite for better branch handling
#attackScenarioPiece(APSet,AttackerMoves,CumulativeP,E,SourceService,TargetService,CurrentP,CompromiseSet,PC,TotalC)
attackScenarioPiece(APSet,AttackerMoves,CumulativeP,E,Leaves,SourceService,TargetService,CurrentP,CompromiseSet,PC,TotalC) <= attackScenarioPiece(APSet,AttackerMoves2,CumulativeP2,E2,Leaves,SourceService,IntermediateService1,CurrentP2,CompromiseSet,PC,TotalC2) & attackerConnectsTo(IntermediateService1,TargetService,VulnType,C,CImpact,IImpact,AImpact) & (AttackerMove==[IntermediateService1,TargetService,VulnType]) & (AttackerMove._not_in(AttackerMoves2)) & (AttackerMoves==AttackerMoves2+[AttackerMove]) & (CumulativeP == CumulativeP2+[TargetService]) & hasCredentials(TargetService,CredentialSet) &  (E == E2+[VulnType]+CredentialSet+['new']) & (CurrentP == CurrentP2+[TargetService]) & (TotalC==TotalC2+C) & (TotalC <= MaxR) & (VulnType._not_in(E2)) & (TargetService._not_in(CumulativeP2))  #

#New above with credential
#attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,AttackerMoves2,TotalC2) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (P==P2+[IntermediateService1]) & (VulnType._not_in(E2)) & (E==E2+[VulnType]) & (TotalC==TotalC2+C) & (TotalC2+C <= MaxR) & (AttackerMove==[IntermediateService1,TargetService,VulnType]) & (AttackerMove._not_in(AttackerMoves2)) & (AttackerMoves==AttackerMoves2+[AttackerMove]) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & hasCredential(TargetService,X) & (X._not_in(E2)) & (E==E2+[X])
#& hasCredential(TargetService,Credential) # & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2))
#Inductive case to continue connectivity, previously-used exploit
attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC,CImpact,IImpact,AImpact) <= attackPaths(SourceService,IntermediateService1,P2,E2,AttackerMoves2,TotalC2,CImpact2,IImpact2,AImpact2) & attackerConnectsTo(IntermediateService1,TargetService,VulnType,C,CImpact3,IImpact3,AImpact3) & (P==P2+[IntermediateService1]) & (VulnType._in(E2)) & (E==E2+[VulnType]) & (TotalC==TotalC2) & (TotalC2 <= MaxR) & (AttackerMove==[IntermediateService1,TargetService,VulnType]) & (AttackerMove._not_in(AttackerMoves2)) & (AttackerMoves==AttackerMoves2+[AttackerMove]) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (CImpact==CImpact2*CImpact3) & (IImpact==IImpact2*IImpact3) & (AImpact==AImpact2*AImpact3) #& (IntermediateService1 != TargetService)
#Rewrite for better branch handling
#attackScenarioPiece(APSet,AttackerMoves,CumulativeP,E,SourceService,TargetService,CurrentP,CompromiseSet,PC,TotalC)
attackScenarioPiece(APSet,AttackerMoves,CumulativeP,E,Leaves,SourceService,TargetService,CurrentP,CompromiseSet,PC,TotalC) <= attackScenarioPiece(APSet,AttackerMoves2,CumulativeP2,E2,Leaves,SourceService,IntermediateService1,CurrentP2,CompromiseSet,PC,TotalC) & attackerConnectsTo(IntermediateService1,TargetService,VulnType,C,CImpact,IImpact,AImpact) & (AttackerMove==[IntermediateService1,TargetService,VulnType]) & (AttackerMove._not_in(AttackerMoves2)) & (AttackerMoves==AttackerMoves2+[AttackerMove]) & (CumulativeP == CumulativeP2+[TargetService]) & hasCredentials(TargetService,CredentialSet) & (E == E2+[VulnType]+CredentialSet+['reused']) & (CurrentP == CurrentP2+[TargetService]) & (TotalC <= MaxR) & (VulnType._in(E2)) & (TargetService._not_in(CumulativeP2)) #& (SourceService!=TargetService)

#New above with credential
#attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,AttackerMoves2,TotalC2) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (P==P2+[IntermediateService1]) & (VulnType._in(E2)) & (E==E2+[VulnType]) & (TotalC==TotalC2) & (TotalC2+C <= MaxR) & (AttackerMove==[IntermediateService1,TargetService,VulnType]) & (AttackerMove._not_in(AttackerMoves2)) & (AttackerMoves==AttackerMoves2+[AttackerMove]) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & hasCredential(TargetService,X) & (X._not_in(E2)) & (E==E2+[X])
#& hasCredential(TargetService,Credential) # & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) 
#Inductive case to begin again at new compromise point, no new exploit necessary
attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC,CImpact,IImpact,AImpact) <= attackPaths(SourceService,IntermediateService1,P2,E2,AttackerMoves2,TotalC,CImpact2,IImpact2,AImpact2) & (P==P2+[TargetService]) & compromised(TargetService,PC3,CImpact3,IImpact3,AImpact3) & (E==E2+['compromised']) & (TotalC <= MaxR) & (AttackerMove==[IntermediateService1,TargetService,'compromised']) & (AttackerMove._not_in(AttackerMoves2)) & (AttackerMoves==AttackerMoves2+[AttackerMove]) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (CImpact==CImpact2*CImpact3) & (IImpact==IImpact2*IImpact3) & (AImpact==AImpact2*AImpact3)
#This removes loops: & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) 
 #& hasCredential(TargetService,Credential)  # & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & & isType(TargetService,ComponentType) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (VulnType._in(E2))
#Rewrite for better branch handling
# The requirement for the current path to be empty is to prevent new compromise after scenario generation termination
#attackScenarioPiece(APSet,AttackerMoves,CumulativeP,E,Leaves,SourceService,TargetService,CurrentP,CompromiseSet,PC,TotalC)
attackScenarioPiece(APSet,AttackerMoves,CumulativeP,E,Leaves,TargetService,TargetService,CurrentP,CompromiseSet,PC,TotalC) <= attackScenarioPiece(APSet2,AttackerMoves2,CumulativeP2,E2,Leaves2,SourceService2,IntermediateService1,CurrentP2,CompromiseSet2,PC2,TotalC) & compromised(TargetService,PC3,CImpact3,IImpact3,AImpact3) & (AttackerMove==[TargetService,TargetService,'compromised'+TargetService]) & (AttackerMove._not_in(AttackerMoves2)) & (AttackerMoves==AttackerMoves2+[AttackerMove]) & (CumulativeP == CumulativeP2+[TargetService]) & hasCredentials(TargetService,CredentialSet) & (E == E2+['compromisedBranch']+CredentialSet) & (Leaves == Leaves2+[IntermediateService1]) & (CurrentP == [TargetService]) & (APSet == APSet2+[CurrentP2]) & (CompromiseSet == CompromiseSet2+[TargetService]) & (PC == PC2*PC3) & (TotalC <= MaxR) & (VulnType._in(E2)) & (TargetService._not_in(CumulativeP2)) & (CurrentP2 != [])

#Inductive case to branch at earlier point, no new exploit necessary
#Because we're continuing from an existing compromise point, we don't need to store away the current path and start fresh
#attackScenarioPiece(APSet,AttackerMoves,CumulativeP,E,Leaves,SourceService,TargetService,CurrentP,CompromiseSet,PC,TotalC)
attackScenarioPiece(APSet,AttackerMoves,CumulativeP,E,Leaves,SourceService,TargetService3,CurrentP,CompromiseSet,PC,TotalC) <= attackScenarioPiece(APSet,AttackerMoves2,CumulativeP2,E2,Leaves2,SourceService,TargetService2,CurrentP2,CompromiseSet,PC,TotalC) & attackerConnectsTo(IntermediateService1,TargetService3,VulnType,C,CImpact,IImpact,AImpact) & (AttackerMove==[IntermediateService1,TargetService3,VulnType]) & (AttackerMove._not_in(AttackerMoves2)) & (AttackerMoves==AttackerMoves2+[AttackerMove]) & (Leaves == Leaves2+[TargetService2]) & (CumulativeP == CumulativeP2+[TargetService3]) & hasCredentials(TargetService3,CredentialSet) & (E == E2+['exploitedBranch']+CredentialSet) & (CurrentP == CurrentP2+[TargetService3]) & (TotalC <= MaxR) & (VulnType._in(E2)) & (TargetService3._not_in(CumulativeP2)) & (IntermediateService1._in(CurrentP2)) & (IntermediateService1 != TargetService2) & IntermediateService1._not_in(Leaves2) #& (AP == [SourceService3,IntermediateService1,P3]) & AP._not_in(APSet) 

#Note, I think I can reduce the branches by tracking leaves...new branches add leaf to a list, and we can't branch from any leaves in that list (because that's not really a new branch but rather extending an existing branch)
#Inductive case to branch at earlier point, new exploit necessary
#Because we're continuing from an existing compromise point, we don't need to store away the current path and start fresh
#attackScenarioPiece(APSet,AttackerMoves,CumulativeP,E,Leaves,SourceService,TargetService,CurrentP,CompromiseSet,PC,TotalC)
attackScenarioPiece(APSet,AttackerMoves,CumulativeP,E,Leaves,SourceService,TargetService3,CurrentP,CompromiseSet,PC,TotalC) <= attackScenarioPiece(APSet,AttackerMoves2,CumulativeP2,E2,Leaves2,SourceService,TargetService2,CurrentP2,CompromiseSet,PC,TotalC2) & attackerConnectsTo(IntermediateService1,TargetService3,VulnType,C,CImpact,IImpact,AImpact) & (AttackerMove==[IntermediateService1,TargetService3,VulnType]) & (AttackerMove._not_in(AttackerMoves2)) & (AttackerMoves==AttackerMoves2+[AttackerMove]) & (Leaves == Leaves2+[TargetService2]) & (CumulativeP == CumulativeP2+[TargetService3]) & hasCredentials(TargetService3,CredentialSet) & (E == E2+['exploitedBranch']+CredentialSet) & (CurrentP == CurrentP2+[TargetService3]) & (TotalC == TotalC2+C) & (TotalC <= MaxR) & (VulnType._not_in(E2)) & (TargetService3._not_in(CumulativeP2)) & (IntermediateService1._in(CurrentP2)) & (IntermediateService1 != TargetService2) & IntermediateService1._not_in(Leaves2) #& (AP == [SourceService3,IntermediateService1,P3]) & AP._not_in(APSet) 

# Inductive case to store current path into the attack path set and save as a terminated attack
# We're treating this as a special case of a branch
#attackScenarioPiece(APSet,AttackerMoves,CumulativeP,E,Leaves,SourceService,TargetService,CurrentP,CompromiseSet,PC,TotalC)
attackScenarioPiece(APSet,AttackerMoves,CumulativeP,E,[],'TERMINATED','TERMINATED',CurrentP,CompromiseSet,PC,TotalC) <= attackScenarioPiece(APSet2,AttackerMoves2,CumulativeP2,E2,Leaves2,SourceService2,IntermediateService1,CurrentP2,CompromiseSet,PC,TotalC) & (AttackerMove==['TERMINATED','TERMINATED','TERMINATED']) & (AttackerMove._not_in(AttackerMoves2)) & (AttackerMoves==AttackerMoves2+[AttackerMove]) & (CumulativeP == CumulativeP2+['TERMINATED']) & (E == E2+['TERMINATED']) & (CurrentP == []) & (APSet == APSet2+[CurrentP2]) & (TotalC <= MaxR) 
# SAME AS ABOVE
# attackScenario(APSet,AttackerMoves2,CumulativeP,E,CompromiseSet,PC,TotalC)
attackScenario(APSet,AttackerMoves2,CumulativeP2,E2,CompromiseSet,PC,TotalC) <= attackScenarioPiece(APSet2,AttackerMoves2,CumulativeP2,E2,Leaves2,SourceService2,IntermediateService1,CurrentP2,CompromiseSet,PC,TotalC) & (AttackerMove==['TERMINATED','TERMINATED','TERMINATED']) & (AttackerMove._not_in(AttackerMoves2)) & (APSet == APSet2+[CurrentP2]) & (TotalC <= MaxR)

#functionAffected(attackScenarioPiece(),Function,CImpact,IImpact,AImpact)
#<= 
#consumptionPath() <= attackScenarioPiece() & consumes() & produces() & requires() <= attackScenarioPiece() & consumes() & produces() & requires()

 #Inductive case to continue connectivity, using a credential captured earlier
 #Based on inductive case for using previously-used exploit
 # X == VulnType; TotalC2 <= MaxR
attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC,CImpact,IImpact,AImpact) <= attackPaths(SourceService,IntermediateService1,P2,E2,AttackerMoves2,TotalC2,CImpact2,IImpact2,AImpact2) & attackerConnectsTo(IntermediateService1,TargetService,Credential,C2,CCImpact2,IImpact2,AImpact2) & usesCredential(TargetService,Credential) & (P==P2+[IntermediateService1]) & (Credential._in(E2)) & (E==E2+[Credential]) & (TotalC==TotalC2) & (TotalC2 <= MaxR) & (AttackerMove==[IntermediateService1,TargetService,Credential]) & (AttackerMove._not_in(AttackerMoves2)) & (AttackerMoves==AttackerMoves2+[AttackerMove]) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2))

 #Add credential to available exploits if we exploit a service that has a credential
 attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC,CImpact,IImpact,AImpact) <= attackPaths(SourceService,TargetService,P,E2,AttackerMoves,TotalC,CImpact,IImpact,AImpact) & hasCredential(TargetService,X) & (X._not_in(E2)) & (E==E2+[X])


#DELETE
#Inductive case to start new branch, no exploit because already compromised
#attackPaths(SourceService,TargetService,P,E,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,TotalC2) & compromised(TargetService) & (SourceService!=TargetService) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (E==E2+[]) & (TotalC==TotalC2) & (TotalC2+C <= MaxR) # cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService._not_in(P2))
#Inductive case to start new branch, no exploit because already in attack path
#attackPaths(SourceService,TargetService,P,E,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,TotalC2) & compromised(TargetService) & (SourceService!=TargetService) & (TargetService._in(P2)) & (P==P2+[IntermediateService1]) & (E==E2+[]) & (TotalC==TotalC2) & (TotalC2+C <= MaxR)




#Base case special case for first starting point
#attachPaths(Paths,Exploits,Cost)
#attackPaths([P],[],0) <= compromised(SourceService) & (P==[[SourceService],[]]) & P._not_in(Paths) & (Paths==[P])
#Base case special case for a subsequent starting points
#attackPaths(Paths,[],0) <= attackPaths(Paths2,[],TotalC) & compromised(SourceService) & (P==[[SourceService],[]]) & P._not_in(Paths2) & (Paths==Paths2+[P])
#Base case for extension of a single path 
#attackPaths(Paths,Exploits,TotalC) <= compromised(SourceService) & cToWithPrivileges(SourceService,TargetService,VulnType,TotalC) & (P==[[SourceService,TargetService],[VulnType]]) & (TotalC <= MaxR) & isType(TargetService,ComponentType) & P._not_in(Paths) & (Paths==[P])
#Inductive case, new exploit
#attackPaths(Paths,Exploits,TotalC) <= attackPaths(Paths2,Exploits2,TotalC2) & (P2._in(Paths2)) & (P2==) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (VulnType._not_in(E2)) & (E==E2+[VulnType]) & (TotalC==TotalC2+C) & (TotalC2+C <= MaxR) & isType(TargetService,ComponentType) 
#Inductive case, previously-used exploit
#attackPaths(SourceService,TargetService,P,E,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,TotalC2) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (VulnType._in(E2)) & (E==E2+[VulnType]) & (TotalC==TotalC2) & (TotalC2+C <= MaxR) & isType(TargetService,ComponentType)


#Thought: (E==E2+[VulnType,ComponentType]) & isType(IntermediateService1,ComponentType) #I need to not use isType in a subType manner elsewhere then?
#Add new supertype with cost
#Same type no new cost


#TODO: Refine this
#compromised(ServiceA) <= probCompromised(ServiceA,P)
#compromised(TargetService) <= componentCompromisedWithAttributes(TargetService,P,CProvided,IProvided,AProvided)

#This is a connection across which an attacker can traverse
#cToWithPrivileges(SourceService,TargetService,'legitimate',0) <= residesOn(SourceService,TargetService)
attackerConnectsTo(SourceService,TargetService,'legitimate',0,0,0,0) <= residesOn(SourceService,TargetService)

#cToWithPrivileges(SourceService,TargetService,'legitimate',0) <= connectsToWithPrivileges(SourceService,TargetService)
#TODO: attackerConnectsToWithPrivileges may no longer be necessary
#Ryan Next TODO: Ensure the CImpact, IImpact, and AImpact are multiples rather than just carrying the values through
#cToWithPrivileges(SourceService,TargetService,VulnType,C,CImpact,IImpact,AImpact,) <= attackerConnectsToWithPrivileges(SourceService,TargetService,VulnType,C,CImpact,IImpact,AImpact)
#attackerConnectsToWithPrivileges(SourceService,TargetService,VulnType,C,CImpact,IImpact,AImpact) <= connectsTo(SourceService,TargetService,CProvided,IProvided,AProvided) & isType(TargetService,ComponentType) & isVulnerable(ComponentType,VulnType,C,CImpact,IImpact,AImpact)

# This creates segments (vectors) of the hypothetical attack path by taking a connection and adding the cost of a particular hypothetical exploit and name of the exploit to the segment
# These are the building blocks of the attack paths
attackerConnectsTo(SourceService,TargetService,VulnType,C,CImpact,IImpact,AImpact) <= connectsTo(SourceService,TargetService,CProvided,IProvided,AProvided) & isType(TargetService,ComponentType) & isVulnerable(ComponentType,VulnType,C,CImpact,IImpact,AImpact)

# This line is needed to make sure the attackerConnectsTo and rule above works
isType(TargetService,TargetService) <= usesCredential(TargetService,X)
# TODO: Expand usesCredential to include CImpact, etc. that's passed
# through to isVulnerable
# NOTE: 1,000,000 is chosen arbitrarily to be high
isVulnerable(TargetService,X,1000000,0,0,0) <= usesCredential(TargetService,X)
# A compromised component has a "vulnerability" associated with it for the purposes of the attack path impacts
isVulnerable(TargetService,X,1000000,0,0,0) <= compromised(TargetService,PC,CImpact,IImpact,AImpact) & (X == 'compromised'+TargetService)

#If a service is in the path, the functions that require it are compromised
#Start with SourceService
pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC,CImpact,IImpact,AImpact) & requires(FuncName,SourceService) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E])
#Then the TargetService
pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC,CImpact,IImpact,AImpact) & requires(FuncName,TargetService) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E])
#And any other services in the path
pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC,CImpact,IImpact,AImpact) & ServiceA._in(P) & requires(FuncName,ServiceA) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E])
#pathCompromisesService(P,ServiceA) <= attackPaths(SourceService,TargetService,P,E,TotalC,MaxR) & (ServiceA._in(P))
#isPath(P) <= attackPaths(SourceService,TargetService,P,E,TotalC)
#path_compromises(P,FuncName) <= attackPaths(SourceService,TargetService,P,E,TotalC,MaxR) & ServiceA._in(P) & requires(FuncName,ServiceA)
#This is to include all compromised components, including those not on the path
#CHANGED TO REMOVE
#pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,TotalC) & compromised(OtherService) & requires(FuncName,OtherService) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E])
#Any compromised component must also be included
#TODO Next: Undo comment and Ensure probability here for multiple points of simultaneous compromise
#pathCompromisesFunctionWithCost(X,FuncName,Util,0) <= compromised(OtherService,PC,CImpact,IImpact,AImpact) & requires(FuncName,OtherService) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E]) & attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC,CImpact,IImpact,AImpact)

#Path compromises a function if the attack path includes a service that is in the only viable path for the function's data flows consumption
#path is compromised if: 1. all consumption paths are compromised
# either by 1a: conflict with attack path
# or by 1b: a compromoised component already on attack path
#path is compromised if: 2. no consumption paths
#consumesPathNotCompromisedbyAttack(FuncName,TargetService,Data,DP,AP) <= consumesPath(FuncName,TargetService,Data,DP) & consumesData(FuncName,TargetService,Data,COK,CImpact,IOK,IImpact,AOK,AImpact) & attackPaths(SourceService,TargetService,AP,E,AttackerMoves,TotalC)
#pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) & consumesPath(FuncName,TargetService,Data,P2) & consumesData(FuncName,TargetService,Data,COK,CImpact,IOK,IImpact,AOK,AImpact) & pathsDontConflict(P,P2) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E]) #Do I need to do source and target service, too?

#TODO Next: produces and consumes
#pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC,CImpact,IImpact,AImpact) & consumesData(FuncName,TargetService,Data,COK,CImpact,IOK,IImpact,AOK,AImpact) & (numConsumesPaths[FuncName,TargetService,Data] > numConsumesPaths[FuncName,TargetService,Data]) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E]) #Do I need to do source and target service, too?


consumesPathCompromised(FuncName,TargetService,Data,P2) <= consumesPath(FuncName,TargetService,Data,P2) & attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC,CImpact,IImpact,AImpact) & (ServiceA._in(P2)) & (ServiceA._in(P))
consumesPathCompromised(FuncName,TargetService,Data,P2) <= consumesPath(FuncName,TargetService,Data,P2) & attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC,CImpact,IImpact,AImpact) & (TargetService._in(P2))
consumesPathCompromised(FuncName,TargetService,Data,P2) <= consumesPath(FuncName,TargetService,Data,P2) & attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC,CImpact,IImpact,AImpact) & (SourceService._in(P2))

(numConsumesPaths[FuncName,TargetService,Data] == len_(P2)) <= consumesPath(FuncName,TargetService,Data,P2)
(numConsumesPathsCompromised[FuncName,TargetService,Data] == len_(P2)) <= consumesPathCompromised(FuncName,TargetService,Data,P2)
#(concatConsumesPathsCompromised[FuncName,TargetService,Data] == concat_([FuncName,TargetService,Data], order_by=FuncName, sep=',') <= consumesPath(FuncName,TargetService,Data,P2)

pathsConflict(P,P2) <= ServiceA._in(P) & ServiceA._in(P2)
pathsDontConflict(P,P2) <= ~pathsConflict(P,P2)


#There is no path that exists in consumesDataWithAttributes T/T/T for which an element of the attack path is in an element of the consumes path. Maybe do path doesn't compromise? By saying a path exists
#pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) & consumesDataWithAttributes(FunctionA,ServiceA,Data,True,CImpact,True,IImpact,True,AImpact,P2) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E]) 
#pathDoesntCompromiseFunctionWithCost() <= attackPaths(X,FuncName,Util,TotalC) & consumesDataWithAttributes(FunctionA,ServiceA,Data,True,CImpact,True,IImpact,True,AImpact,P2) & no elements of P2 are in P & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E]) 
#Do I need to do source and target service, too?
#pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) & consumesData(FuncName,ServiceA,Data,COK,CImpact,IOK,IImpact,AOK,AImpact) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E]) #Do I need to do source and target service, too?
#If we have a consumesData, then a function clearly requires it, right?
#pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) & consumesDataWithAttributesUnderAttack(FuncName,ServiceA,Data,COK,CImpact,False,IImpact,AOK,AImpact,DFP,P) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E]) #Do I need to do source and target service, too?
#pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) & consumesDataWithAttributesUnderAttack(FuncName,ServiceA,Data,COK,CImpact,IOK,IImpact,False,AImpact,DFP,P) #Do I need to do source and target service, too?
