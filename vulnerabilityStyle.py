compromised(ServiceA) <= probCompromised(ServiceA,P)

#This is new to handle specifically when we have a point of compromise on the system and
#it's isolated from the rest of the system
#if there's any path and something not in the path compromised, add the functionlity and utility

#P[X]==concat_(Y, order_by=Z, sep=',')) <= body
#(allCompromised[ServiceB]==concat_(ServiceA, key=ServiceA, sep=',')) <= compromised(ServiceA) & (ServiceB==True)
#(P[X]==tuple_(Y, order_by=Z)) <= body
(allCompromised[P]==tuple_(SourceService, order_by=SourceService)) <= compromised(SourceService)

#Inductive Case
#someCompromised(P) <= someCompromised(P2) & compromised(SourceService) & (SourceService._not_in(P2)) & (P==P2+[SourceService])
#Base Case
#someCompromised(P) <= compromised(SourceService) & (P==[SourceService])

#TODO: Is this necessary, or can I find these some other way?
#TODO: Base case should include compromised and build only from there?
allAttackerPathsCostPlus(SourceService,TargetService,P,E,F,U,TotalC,MaxR) <= allAttackerPathsCostPlus(SourceService,TargetService,P,E,F2,U2,TotalC,MaxR) & requires(FuncName,OtherService) & compromised(OtherService) & (FuncName._not_in(F2)) & (F==F2+[FuncName]) & utility(FuncName,Util) & (U == U2+Util)

#This is to include the functionality on the TargetService
allAttackerPathsCostPlus(SourceService,TargetService,P,E,F,U,TotalC,MaxR) <= allAttackerPathsCostPlus(SourceService,TargetService,P,E,F2,U2,TotalC,MaxR) & requires(FuncName,TargetService) & (FuncName._not_in(F2)) & (F==F2+[FuncName]) & utility(FuncName,Util) & (U == U2+Util)
#New to fix bug when compromise is in the source service for the base case
allAttackerPathsCostPlus(SourceService,TargetService,P,E,F,U,TotalC,MaxR) <= allAttackerPathsCostPlus(SourceService,TargetService,P,E,F2,U2,TotalC,MaxR) & requires(FuncName,SourceService) & (FuncName._not_in(F2)) & (F==F2+[FuncName]) & utility(FuncName,Util) & (U == U2+Util)
#This is the version for when the functionality F is already on the path
#NOTE? What if the component serves multiple functions? Does this work to add both?
#Perhaps remove the not seen before logic for being in the attack path and keep the not seen
#before logic for being an affected function
#Add utility mentions across and addtion...and make sure U, U2, Util is already defined
#NOTE? Make sure that, if an attack path goes through a path node with a zero cost path to another function, that other function is also questionable (e.g., superuser of a component with separate functionality)
# General inductive case with new intermediate service and affected functionality
#TODO Combine this and the below by using a lambda
#TODO Or maybe use an aggregate function to get all the paths
#allAttackerPathsCostPlus(SourceService,TargetService,P,E,F,U,TotalC,MaxR) <= allAttackerPathsCostPlus(SourceService,IntermediateService1,P2,E2,F2,U2,TotalC2,MaxR) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (E==E2+[VulnType]) & (TotalC==TotalC2+C) & (TotalC2+C <= MaxR) & requires(FuncName,IntermediateService1) & (F == (lambda F2, FuncName: (F2+[FuncName]) if FuncName._not_in(F2) else F2)) & utility(FuncName,Util) & (U == (lambda U2, Util, F2, FuncName: (U2+Util) if FuncName._not_in(F2) else U2)) & compromised(SourceService)

allAttackerPathsCostPlus(SourceService,TargetService,P,E,F,U,TotalC,MaxR) <= allAttackerPathsCostPlus(SourceService,IntermediateService1,P2,E2,F2,U2,TotalC2,MaxR) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (E==E2+[VulnType]) & (TotalC==TotalC2+C) & (TotalC2+C <= MaxR) & requires(FuncName,IntermediateService1) & (FuncName._not_in(F2)) & (F==F2+[FuncName]) & utility(FuncName,Util) & (U == U2+Util) & compromised(SourceService)
#Inductive case for when F has already been seen
allAttackerPathsCostPlus(SourceService,TargetService,P,E,F,U,TotalC,MaxR) <= allAttackerPathsCostPlus(SourceService,IntermediateService1,P2,E2,F2,U2,TotalC2,MaxR) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (E==E2+[VulnType]) & (TotalC==TotalC2+C) & (TotalC2+C <= MaxR) & requires(FuncName,IntermediateService1) & (FuncName._in(F2)) & (F==F2) & (U==U2) & compromised(SourceService)
#Inductive case when there are multiple functions for the intermediate service that has already been added to the path. Don't add anything to path, but add to function list and util affected
#NOTE? Should this instead/also apply to the base case?
allAttackerPathsCostPlus(SourceService,TargetService,P,E,F,U,TotalC,MaxR) <= allAttackerPathsCostPlus(SourceService,IntermediateService1,P2,E2,F2,U2,TotalC2,MaxR) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2) & (E==E2) & (TotalC==TotalC2) & (TotalC2 <= MaxR) & requires(FuncName,IntermediateService1) & (IntermediateService1._in(P2)) & (FuncName._not_in(F2)) & (F==F2+[FuncName]) & utility(FuncName,Util) & (U==U2+Util) & compromised(SourceService)
#Inductive case when there is other functionality that's already broken
#Changed from functionQuestionable to functionDown
allAttackerPathsCostPlus(SourceService,TargetService,P,E,F,U,TotalC,MaxR) <= allAttackerPathsCostPlus(SourceService,TargetService,P,E,F2,U2,TotalC,MaxR) & functionDown(FuncName,Util) & (FuncName._not_in(F2)) & (F==F2+[FuncName]) & utility(FuncName,Util) & (U==U2+Util)
#Base case
#NOTE: What if there's no affected functionality?
#NOTE? The sourceservice here is compromised, but the requires is for the target service...
allAttackerPathsCostPlus(SourceService,TargetService,P,[VulnType],[FuncName],Util,TotalC,MaxR) <= cToWithPrivileges(SourceService,TargetService,VulnType,TotalC) & (P==[]) & (TotalC <= MaxR) & requires(FuncName,TargetService) & utility(FuncName,Util) & compromised(SourceService)
#Base case for when there's no affected functionality
#allAttackerPathsCostPlus(SourceService,TargetService,P,[VulnType],F,Util,TotalC,MaxR) <= cToWithPrivileges(SourceService,TargetService,VulnType,TotalC) & (P==[]) & (TotalC <= MaxR) & functionalityFree(TargetService) & compromised(SourceService) & (F==[]) & (Util==0)

#This is new to handle specifically when we have a point of compromise on the system and
#it's isolated from the rest of the system
#if there's any path and something not in the path compromised, add the functionlity and utility
#TODO: Shouldn't this be in the base case?
allAttackerPathsCostPlus(SourceService,TargetService,P,E,F,U,TotalC,MaxR) <= allAttackerPathsCostPlus(SourceService,TargetService,P,E,F2,U2,TotalC,MaxR) & requires(FuncName,OtherService) & compromised(OtherService) & (FuncName._not_in(F2)) & (F==F2+[FuncName]) & utility(FuncName,Util) & (U == U2+Util)

#This is to include the functionality on the TargetService
allAttackerPathsCostPlus(SourceService,TargetService,P,E,F,U,TotalC,MaxR) <= allAttackerPathsCostPlus(SourceService,TargetService,P,E,F2,U2,TotalC,MaxR) & requires(FuncName,TargetService) & (FuncName._not_in(F2)) & (F==F2+[FuncName]) & utility(FuncName,Util) & (U == U2+Util)
#New to fix bug when compromise is in the source service for the base case
allAttackerPathsCostPlus(SourceService,TargetService,P,E,F,U,TotalC,MaxR) <= allAttackerPathsCostPlus(SourceService,TargetService,P,E,F2,U2,TotalC,MaxR) & requires(FuncName,SourceService) & (FuncName._not_in(F2)) & (F==F2+[FuncName]) & utility(FuncName,Util) & (U == U2+Util)
#This is the version for when the functionality F is already on the path
#NOTE? What if the component serves multiple functions? Does this work to add both?
#Perhaps remove the not seen before logic for being in the attack path and keep the not seen
#before logic for being an affected function
#Add utility mentions across and addtion...and make sure U, U2, Util is already defined
#NOTE? Make sure that, if an attack path goes through a path node with a zero cost path to another function, that other function is also questionable (e.g., superuser of a component with separate functionality)
# General inductive case with new intermediate service and affected functionality
allAttackerPathsCostPlus(SourceService,TargetService,P,E,F,U,TotalC,MaxR) <= allAttackerPathsCostPlus(SourceService,IntermediateService1,P2,E2,F2,U2,TotalC2,MaxR) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (E==E2+[VulnType]) & (TotalC==TotalC2+C) & (TotalC2+C <= MaxR) & requires(FuncName,IntermediateService1) & (FuncName._not_in(F2)) & (F==F2+[FuncName]) & utility(FuncName,Util) & (U == U2+Util) & compromised(SourceService)
#Inductive case for when F has already been seen
allAttackerPathsCostPlus(SourceService,TargetService,P,E,F,U,TotalC,MaxR) <= allAttackerPathsCostPlus(SourceService,IntermediateService1,P2,E2,F2,U2,TotalC2,MaxR) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (E==E2+[VulnType]) & (TotalC==TotalC2+C) & (TotalC2+C <= MaxR) & requires(FuncName,IntermediateService1) & (FuncName._in(F2)) & (F==F2) & (U==U2) & compromised(SourceService)
#Inductive case when there are multiple functions for the intermediate service that has already been added to the path. Don't add anything to path, but add to function list and util affected
#NOTE? Should this instead/also apply to the base case?
allAttackerPathsCostPlus(SourceService,TargetService,P,E,F,U,TotalC,MaxR) <= allAttackerPathsCostPlus(SourceService,IntermediateService1,P2,E2,F2,U2,TotalC2,MaxR) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2) & (E==E2) & (TotalC==TotalC2) & (TotalC2 <= MaxR) & requires(FuncName,IntermediateService1) & (IntermediateService1._in(P2)) & (FuncName._not_in(F2)) & (F==F2+[FuncName]) & utility(FuncName,Util) & (U==U2+Util) & compromised(SourceService)
#Inductive case when there is other functionality that's already broken
#Changed from functionQuestionable to functionDown
allAttackerPathsCostPlus(SourceService,TargetService,P,E,F,U,TotalC,MaxR) <= allAttackerPathsCostPlus(SourceService,TargetService,P,E,F2,U2,TotalC,MaxR) & functionDown(FuncName,Util) & (FuncName._not_in(F2)) & (F==F2+[FuncName]) & utility(FuncName,Util) & (U==U2+Util)
#Base case
#NOTE: What if there's no affected functionality?
#NOTE? The sourceservice here is compromised, but the requires is for the target service...
allAttackerPathsCostPlus(SourceService,TargetService,P,[VulnType],[FuncName],Util,TotalC,MaxR) <= cToWithPrivileges(SourceService,TargetService,VulnType,TotalC) & (P==[]) & (TotalC <= MaxR) & requires(FuncName,TargetService) & utility(FuncName,Util) & compromised(SourceService)
#Base case for when there's no affected functionality
#allAttackerPathsCostPlus(SourceService,TargetService,P,[VulnType],F,Util,TotalC,MaxR) <= cToWithPrivileges(SourceService,TargetService,VulnType,TotalC) & (P==[]) & (TotalC <= MaxR) & functionalityFree(TargetService) & compromised(SourceService) & (F==[]) & (Util==0)

#New logic. Hopefully better!
#BUG How do I not have to do this?
MaxR=4
#Get the worst case path at each cost
#Cost.in_(range(MaxR+1))
#riskDistribution = RiskPDF(dict([(0,0.20),(1,0.20),(2,0.20),(3,0.20),(4,0.20)]))
#probCapability[0] = 0.01
#probCapability[1] = 0.01
#probCapability[2] = 0.08
#probCapability[3] = 0.30
#probCapability[4] = 0.60

#(probCapability[C] == P) <= pC(C,P)

#BUG Add in each combo of compromised components

(estimatedUtility[TotalC] == sum_(U,for_each=TotalC)) <= (U==weightedWorstCastPath[TotalC])

weightedWorstCasePath[TotalC] = probCapability[TotalC] * worstCasePathValue[TotalC]


#How do I make a set of all the possible combinations of compromised components?
#First create an ordered linked list

#Base case
#compromisedOrderedList(Y) <=
#First in List
#firstCompromised(X) <= compromised(X) &
#Base case if only one is compromised


#Base case if none are compromised

#Then pull things off one by one
#One rule skips the component, the other adds the component

#Inductive case
#compromisedCombo(X) <= compromisedCombo(Y) & compromised(SourceService) & SourceService._not_in(Y) & (X==tuple(sorted(Y+[SourceService]))) #& ~setNotEquals(X,Z)
#Base case
#compromisedCombo(X) <= compromised(SourceService) & (X==[SourceService])

#setNotEquals(X,Y) <= Z._in(X) & Z._not_in(Y)
#setNotEquals(X,Y) <= Z._in(Y) & Z._not_in(X)


#What is the worst cast path at a particular cost?
#min_, max_ (P[X]==min_(Y, order_by=Z)) <= body : P[X] is the minimum (or maximum) of Y sorted by Z
#CHANGED
(worstCasePathValue[TotalC] == max_(U, order_by=U)) <= pathCompromisesWithCost(X,C) & (pathCompromisesUtilities[X] == U) & (pathCompromisesFunctions[X] == FList) & (TotalC >= C)
#(worstCasePathValue[TotalC] == max_(U, order_by=U)) <= pathCompromisesWithCost(X,TotalC) & (pathCompromisesUtilities[X] == U) & (pathCompromisesFunctions[X] == FList)

#CHANGED
(worstCasePathFromSource[SourceService,TotalC] == max_(UtilPathPair, order_by=U)) <= pathCompromisesWithCost(X,C) & (pathCompromisesUtilities[X] == U) & (pathCompromisesFunctions[X] == FList) & (UtilPathPair==[U,FList,X]) & (X==[SourceService,TargetService,P,E]) & (TotalC >= C) # & (X == [SourceService,TargetService,P,E]) & (SourceCost==[SourceService,TotalC])
#(worstCasePathFromSource[SourceService,TotalC] == max_(UtilPathPair, order_by=U)) <= pathCompromisesWithCost(X,TotalC) & (pathCompromisesUtilities[X] == U) & (pathCompromisesFunctions[X] == FList) & (UtilPathPair==[U,FList,X]) & (X==[SourceService,TargetService,P,E]) # & (X == [SourceService,TargetService,P,E]) & (SourceCost==[SourceService,TotalC])
#pathFromSourceWithCost(SourceService,CpathCompromisesWithCost(X,TotalC) & (pathCompromisesUtilities[X] == U) & (pathCompromisesFunctions[X] == FList) & (UtilPathPair==[U,FList,X]) & (X==[SourceService,TargetService,P,E])

#CHANGED
(worstCasePath[TotalC] == max_(UtilPathPair, order_by=U)) <= pathCompromisesWithCost(X,C) & (pathCompromisesUtilities[X] == U) & (pathCompromisesFunctions[X] == FList) & (UtilPathPair==[U,FList,X]) & (TotalC >= C)
#(worstCasePath[TotalC] == max_(UtilPathPair, order_by=U)) <= pathCompromisesWithCost(X,TotalC) & (pathCompromisesUtilities[X] == U) & (pathCompromisesFunctions[X] == FList) & (UtilPathPair==[U,FList,X])
#worstCastPath(X,TotalC) <= pathCompromisesWithCost(X,TotalC) & (pathCompromisesUtilities[X] == U) & worstCastPath(Y,TotalC) &

#What are the paths that exist at a particular cost?
pathCompromisesWithCost(X,TotalC) <= attackPaths(SourceService,TargetService,P,E,TotalC) & (X == [SourceService,TargetService,P,E])
#pathCompromisesWithCostObs(X,TotalC,PObs) <= attackPathsObs(SourceService,TargetService,P,E,TotalC,Obs) & (X == [SourceService,TargetService,P,E])

#What's the value of the compromised functions for a path?
#Running sum would be helpful?
#(P[X]==sum_(Y, for_each=Z)) <= body
(pathCompromisesUtilities[X] == sum_(U2,for_each=X)) <= pathCompromisesFunctionWithCost(X,FuncName,U2,TotalC)
(pathCompromisesFunctions[X] == concat_(FuncName,order_by=FuncName,sep=',')) <= pathCompromisesFunctionWithCost(X,FuncName,U2,TotalC)
#If a service is in the path, the functions that require it are compromised
pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,TotalC) & requires(FuncName,SourceService) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E])
#Above, including the sourceservice
pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,TotalC) & requires(FuncName,TargetService) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E])
#Above, including the targetservice
pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,TotalC) & ServiceA._in(P) & requires(FuncName,ServiceA) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E])
#pathCompromisesService(P,ServiceA) <= attackPaths(SourceService,TargetService,P,E,TotalC,MaxR) & (ServiceA._in(P))
#isPath(P) <= attackPaths(SourceService,TargetService,P,E,TotalC)
#path_compromises(P,FuncName) <= attackPaths(SourceService,TargetService,P,E,TotalC,MaxR) & ServiceA._in(P) & requires(FuncName,ServiceA)
#This is to include all compromised components, including those not on the path
#CHANGED TO REMOVE
#pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,TotalC) & compromised(OtherService) & requires(FuncName,OtherService) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E])
pathCompromisesFunctionWithCost(X,FuncName,Util,0) <= compromised(OtherService) & requires(FuncName,OtherService) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E])


#P is attack path and P2 is flow path
#pathCompromisesFlowWithCost(X,FunctionA,ServiceA,Data,COK,CImpact,IOK,IImpact,AOK,AImpact,P) <= consumesDataWithAttributes(FunctionA,ServiceA,Data,COK,CImpact,IOK,IImpact,AOK,AImpact,P2)


#Base case special case for no capability
attackPaths(SourceService,SourceService,P,[],0) <= compromised(SourceService) & (P==[])
#Base case
attackPaths(SourceService,TargetService,P,[VulnType],TotalC) <= compromised(SourceService) & cToWithPrivileges(SourceService,TargetService,VulnType,TotalC) & (P==[]) & (TotalC <= MaxR)#Inductive case, new exploit
attackPaths(SourceService,TargetService,P,E,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,TotalC2) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (VulnType._not_in(E2)) & (E==E2+[VulnType]) & (TotalC==TotalC2+C) & (TotalC2+C <= MaxR)
#Inductive case, previously-used exploit
attackPaths(SourceService,TargetService,P,E,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,TotalC2) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (VulnType._in(E2))& (E==E2+[VulnType]) & (TotalC==TotalC2) & (TotalC2+C <= MaxR)

#For Observations
#Base case special case for no capability
#attackPathsObs(SourceService,SourceService,P,[],0) <= compromised(SourceService) & (P==[])
#Base case
#attackPathsObs(SourceService,TargetService,P,[VulnType],TotalC) <= compromised(SourceService) & cToWithPrivileges(SourceService,TargetService,VulnType,TotalC) & (P==[]) & (TotalC <= MaxR)
#Inductive case
#attackPathsObs(SourceService,TargetService,P,E,TotalC) <= attackPathsObs(SourceService,IntermediateService1,P2,E2,TotalC2) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (E==E2+[VulnType]) & (TotalC==TotalC2+C) & (TotalC2+C <= MaxR)


cToWithPrivileges(SourceService,TargetService,'legitimate',0) <= residesOn(SourceService,TargetService)
#cToWithPrivileges(SourceService,TargetService,'legitimate',0) <= connectsToWithPrivileges(SourceService,TargetService)
cToWithPrivileges(SourceService,TargetService,VulnType,C) <= attackerConnectsToWithPrivileges(SourceService,TargetService,VulnType,C)


# Service is compromised if the host it resides on is compromised
compromised(TargetService) <= residesOn(TargetService,TargetHost) & compromised(TargetHost)

#FunctionA is questionable if it requires a connection that doesn't exist
functionDown(FunctionA,U) <= requiresConnection(FunctionA,SourceService,TargetService) & ~(transitiveConnects(SourceService,TargetService)) & utility(FunctionA,U)

transitiveConnectionBroken(SourceService,TargetService) <= requiresConnection(FunctionA,SourceService,TargetService) & ~(transitiveConnects(SourceService,TargetService))

#Backward compatibility
probCompromised(TargetService,P) <= componentCompromisedWithAttributes(TargetService,P,CProvided,IProvided,AProvided)

























#Vulnerabilities:

#+ localRootExploit('webServer')
#+ remoteRootExploit('attackerHost')
#+ remoteRootExploit('webServer')

#Remote user exploit is available if the service is running as user
attackerConnectsToWithPrivileges(SourceService,TargetService,'remoteUserExploit',C) <= remoteUserExploit(TargetService,C) & connectsTo(SourceService,TargetService)
vulnExists("remoteUserExploit",TargetService) <= remoteUserExploit(TargetService,C)
+ remoteUserExploit("TestA",0)

#Local root exploit is available if the service is running as user
#localRootExploit definition
attackerConnectsToWithPrivileges(ServiceA,TargetHost,'localRootExploit',C) <= residesOn(ServiceA,TargetHost) & localRootExploit(ServiceA,C)
vulnExists("localRootExploit",TargetService) <= localRootExploit(TargetService,C)
+ localRootExploit("TestA",0)

#Remote root exploit is available if the service is running as root and there is another service on the same host running as user
#remoteRootExploit definition
#Old
attackerConnectsToWithPrivileges(ServiceA,HostB,'remoteRootExploit',C) <= remoteRootExploit(HostB,C) & residesOn(ServiceB,HostB) & connectsTo(ServiceA,ServiceB)
#New
attackerConnectsToWithPrivileges(ServiceA,HostB,'remoteRootExploit',C) <= remoteRootExploitWithAttributes(HostB,C,Confidentiality,Integrity,Availability) & residesOn(ServiceB,HostB) & connectsTo(ServiceA,ServiceB)
#Note: There should be a way to say the attacker connects from service A VIA service B to superuser B so it's clear turning off B will cut the connection. This one above is not entirely accurtate. Maybe this isn't an issue because the vulnerability is in the OS and not the service?
vulnExists("remoteRootExploit",TargetService) <= remoteRootExploit(TargetService,C)
+ remoteRootExploit("TestA",0)
vulnExistsWithAttributes("remoteRootExploit",TargetService,Confidentiality,Integrity,Availability) <= remoteRootExploitWithAttributes(TargetService,C,Confidentiality,Integrity,Availability)
+ remoteRootExploitWithAttributes("TestA",0,False,False,False)

#localUserExploit definition
#remoteUserExploit definition




####Not using the below code


# COMPROMISE LOGIC
