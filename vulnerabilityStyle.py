#Vulnerabilities:

#+ localRootExploit('webServer')
#+ remoteRootExploit('attackerHost')
#+ remoteRootExploit('webServer')

#Remote user exploit is available if the service is running as user
attackerConnectsToWithPrivileges(SourceService,TargetService,'remoteUserExploit',C) <= remoteUserExploit(TargetService,C) & connectsTo(SourceService,TargetService)
vulnExists("remoteUserExploit",TargetService) <= remoteUserExploit(TargetService,C)
+ remoteUserExploit("TestA",0)

#Local root exploit is available if the service is running as user
#localRootExploit definition
attackerConnectsToWithPrivileges(ServiceA,TargetHost,'localRootExploit',C) <= residesOn(ServiceA,TargetHost) & localRootExploit(ServiceA,C)
vulnExists("localRootExploit",TargetService) <= localRootExploit(TargetService,C)
+ localRootExploit("TestA",0)

#Remote root exploit is available if the service is running as root and there is another service on the same host running as user
#remoteRootExploit definition
attackerConnectsToWithPrivileges(ServiceA,HostB,'remoteRootExploit',C) <= remoteRootExploit(HostB,C) & residesOn(ServiceB,HostB) & connectsTo(ServiceA,ServiceB)
#Note: There should be a way to say the attacker connects from service A VIA service B to superuser B so it's clear turning off B will cut the connection. This one above is not entirely accurtate. Maybe this isn't an issue because the vulnerability is in the OS and not the service?
vulnExists("remoteRootExploit",TargetService) <= remoteRootExploit(TargetService,C)
+ remoteRootExploit("TestA",0)

cToWithPrivileges(SourceService,TargetService,'legitimate',0) <= connectsToWithPrivileges(SourceService,TargetService)
cToWithPrivileges(SourceService,TargetService,VulnType,C) <= attackerConnectsToWithPrivileges(SourceService,TargetService,VulnType,C)

#Find all attack scenarios within the cost metric
allAttackerPaths(SourceService,TargetService,P,E,TotalC) <= allAttackerPaths(SourceService,IntermediateService1,P2,E2,TotalC2) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (E==E2+[VulnType]) & (TotalC==TotalC2+C) & (TotalC2+C <= maxRisk)
#Base case
allAttackerPaths(SourceService,TargetService,P,[VulnType],TotalC) <= cToWithPrivileges(SourceService,TargetService,VulnType,TotalC) & (P==[]) & (C==0)

#A service is questionable if it's reachable within the risk metric from a compromised service
questionable(TargetService) <= compromised(SourceService) & allAttackerPaths(SourceService,TargetService,P,E,TotalC) & (TotalC <= maxRisk)
questionableWithinRisk(TargetService,RiskLimit) <= compromised(SourceService) & allAttackerPaths(SourceService,TargetService,P,E,TotalC) & (TotalC <= RiskLimit)

#functionA is questionable and has utility U
functionQuestionable(FunctionA,U) <= requires(FunctionA,ServiceA) & questionable(ServiceA) & utility(FunctionA,U)
functionQuestionableWithinRisk(FunctionA,U,RiskLimit) <= requires(FunctionA,ServiceA) & questionableWithinRisk(ServiceA,RiskLimit) & utility(FunctionA,U)
#TODO This should be functionUnavailable
#BUG below
#functionQuestionable(FunctionA,U) <= requiresConnection(FunctionA,SourceService,TargetService) & ~(connectsTo(SourceService,TargetService)) & utility(FunctionA,U)
functionQuestionable(FunctionA,U) <= requiresConnection(FunctionA,SourceService,TargetService) & ~(transitiveConnects(SourceService,TargetService)) & utility(FunctionA,U)
functionQuestionableWithinRisk(FunctionA,U,RiskLimit) <= requiresConnection(FunctionA,SourceService,TargetService) & ~(transitiveConnects(SourceService,TargetService)) & utility(FunctionA,U)
#For debugging
missingConnection(SourceService,TargetService) <= requiresConnection(FunctionA,SourceService,TargetService) & ~(transitiveConnects(SourceService,TargetService))

#localUserExploit definition
#remoteUserExploit definition
#function is compromised/questionable if service is required and compromised/questionable
functionCompromised(FunctionA,U) <= requires(FunctionA,ServiceA) & compromised(ServiceA) & utility(FunctionA,U)
#function is compromised/questionable if two connected services are both required and can't reach each other
#functionCompromised(FunctionA,C) <= requires(FunctionA,ServiceA) & compromised(ServiceA) & utility(FunctionA,C)
#I don't know that the below statement works
functionUncompromised(FunctionA,U) <= ~(functionCompromised(FunctionA,U))

# COMPROMISE LOGIC

# Service is compromised if the host it resides on is compromised
compromised(TargetService) <= residesOn(TargetService,TargetHost) & compromised(TargetHost)

#questionable(TargetService) means in allAttackerPaths(SourceService,TargetService,P,E,TotalC) where SourceService is any compromised service, P is anything, E is anything, and TotalC is a chosen risk metric
