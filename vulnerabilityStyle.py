#compromiseCombo,pathCompromisesWithCostCombo,Combo
#+ compromiseCombo([])
#compromiseCombo(Y) <= compromiseCombo(X) & compromised(TargetService) & TargetService._not_in(X) & (Y == X + [TargetService])

#pathCompromisesWithCostCombo(X,TotalC,Combo) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) & (X == [SourceService,TargetService,P,E]) & (Y._in(Combo)) & (Y._in(E))

(worstCasePathCombo[TotalC,Combo] == max_(UtilPathPair, order_by=U)) <= pathCompromisesWithCost(X,C) & (pathCompromisesUtilities[X] == U) & (pathCompromisesFunctions[X] == FList) & (UtilPathPair==[U,FList,X,Combo]) & (TotalC >= C) & (X == [SourceService,TargetService,P,E]) & (Y._in(Combo)) & (Y._in(E))

#New codespace
#ASKED
#What is the worst case attack path for a given attacker capability?
#TotalC is the given attacker capability
#We find all the paths that exist for a given capability C that is <= TotalC
#Then we choose the max (worst)
(worstCasePath[TotalC] == max_(UtilPathPair, order_by=U)) <= pathCompromisesWithCost(X,C) & (pathCompromisesUtilities[X] == U) & (pathCompromisesFunctions[X] == FList) & (UtilPathPair==[U,FList,X]) & (TotalC >= C) #& (TotalC <= MaxR)

#(worstCasePathSpecific[TotalC,Y] == max_(UtilPathPair, order_by=U)) <= pathCompromisesWithCost(X,C) & (pathCompromisesUtilities[X] == U) & (pathCompromisesFunctions[X] == FList) & (UtilPathPair==[U,FList,X]) & (TotalC >= C) & (X == [SourceService,TargetService,P,E]) & (Y._in(E)) & compromised(Y)

#worstCasePaths(TotalC) <= worstCasePath(TotalC) & (TotalC <= MaxR)

#BUG Fix this
MaxR=4

#ASKED
weightedWorstCasePath[TotalC] = probCapability[TotalC] * worstCasePathValue[TotalC]
#weightedWorstCasePath[TotalC] = probCapability(TotalC,p) * worstCasePathValue[TotalC]


#What are the paths that exist at a particular cost?
pathCompromisesWithCost(X,TotalC) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) & (X == [SourceService,TargetService,P,E])

#What's the value of the compromised functions for a path?
#Running sum would be helpful?
#(P[X]==sum_(Y, for_each=Z)) <= body
(pathCompromisesUtilities[X] == sum_(U2,for_each=X)) <= pathCompromisesFunctionWithCost(X,FuncName,U2,TotalC)

(pathCompromisesFunctions[X] == concat_(FuncName,order_by=FuncName,sep=',')) <= pathCompromisesFunctionWithCost(X,FuncName,U2,TotalC)

#Base case special case for no capability
#attackPaths(SourceService,SourceService,P,[],0) <= compromised(SourceService) & (P==[])
#Base case
#attackPaths(SourceService,TargetService,P,[VulnType],TotalC) <= compromised(SourceService) & cToWithPrivileges(SourceService,TargetService,VulnType,TotalC) & (P==[]) & (TotalC <= MaxR)
#Inductive case, new exploit
#attackPaths(SourceService,TargetService,P,E,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,TotalC2) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (VulnType._not_in(E2)) & (E==E2+[VulnType]) & (TotalC==TotalC2+C) & (TotalC2+C <= MaxR)
#Inductive case, previously-used exploit
#attackPaths(SourceService,TargetService,P,E,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,TotalC2) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (VulnType._in(E2)) & (E==E2+[VulnType]) & (TotalC==TotalC2) & (TotalC2+C <= MaxR)

#New Version for Types:
#Note, now each component must have an associated type
#Assumption that the attacker exploits specifically for the component type and not for a component super type
#Base case special case for no capability
#attackPaths(SourceService,SourceService,P,[],0) <= compromised(SourceService) & (P==[])
#Base case
#attackPaths(SourceService,TargetService,P,[VulnType],TotalC) <= compromised(SourceService) & cToWithPrivileges(SourceService,TargetService,VulnType,TotalC) & (P==[]) & (TotalC <= MaxR) & isType(TargetService,ComponentType)
#Inductive case, new exploit
#attackPaths(SourceService,TargetService,P,E,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,TotalC2) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (VulnType._not_in(E2)) & (E==E2+[VulnType]) & (TotalC==TotalC2+C) & (TotalC2+C <= MaxR) & isType(TargetService,ComponentType)
#Inductive case, previously-used exploit
#attackPaths(SourceService,TargetService,P,E,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,TotalC2) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (VulnType._in(E2)) & (E==E2+[VulnType]) & (TotalC==TotalC2) & (TotalC2+C <= MaxR) & isType(TargetService,ComponentType)


#Note: Sometimes, as we build a trace, we charge the cost for exploiting something "compromised" and sometimes don't, but always be consistent with the previous moves (in cases of branching), and returning through source is always free (in cases of branching). This way, we can generate in one shot all the traces for all possible combinations of compromises.
#What I need to change: I need to have two different types of exploit for compromised components. One is assuming compromise at initial state (so cost of exploit is zero), and the other is assume no compromise at initial state (so cost of exploit is non-zero).
#Then, I need to pull all the worst case scenarios based on each combo of compromises (represented in AttackerMoves) and reconstruct the numbers from there

 #Add credential to available exploits if we exploit a service that has a credential
 attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) <= attackPaths(SourceService,TargetService,P,E2,AttackerMoves,TotalC) & hasCredential(TargetService,X) & (X._not_in(E2)) & (E==E2+[X])
#New with Types and Branching
#Base case for first compromised component
#New Added SourceService to E
attackPaths(SourceService,SourceService,P,[SourceService],AttackerMoves,0) <= compromised(SourceService) & (P==[]) & (AttackerMoves==[[SourceService,SourceService,SourceService]]) #& hasCredential(SourceService,Credential)
#Base case to continue connectivity with first exploit
#Note: Is this needed anymore given the above base case?
attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) <= compromised(SourceService) & cToWithPrivileges(SourceService,TargetService,VulnType,TotalC) & (P==[]) & (E==[VulnType]) & (TotalC <= MaxR) & isType(TargetService,ComponentType) & (AttackerMoves==[[SourceService,TargetService,VulnType]]) #& hasCredential(TargetService,Credential)
#Inductive case to continue connectivity, new exploit
attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,AttackerMoves2,TotalC2) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (P==P2+[IntermediateService1]) & (VulnType._not_in(E2)) & (E==E2+[VulnType]) & (TotalC==TotalC2+C) & (TotalC2+C <= MaxR) & (AttackerMove==[IntermediateService1,TargetService,VulnType]) & (AttackerMove._not_in(AttackerMoves2)) & (AttackerMoves==AttackerMoves2+[AttackerMove]) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2))

#New above with credential
#attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,AttackerMoves2,TotalC2) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (P==P2+[IntermediateService1]) & (VulnType._not_in(E2)) & (E==E2+[VulnType]) & (TotalC==TotalC2+C) & (TotalC2+C <= MaxR) & (AttackerMove==[IntermediateService1,TargetService,VulnType]) & (AttackerMove._not_in(AttackerMoves2)) & (AttackerMoves==AttackerMoves2+[AttackerMove]) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & hasCredential(TargetService,X) & (X._not_in(E2)) & (E==E2+[X])
#& hasCredential(TargetService,Credential) # & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2))
#Inductive case to continue connectivity, previously-used exploit
attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,AttackerMoves2,TotalC2) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (P==P2+[IntermediateService1]) & (VulnType._in(E2)) & (E==E2+[VulnType]) & (TotalC==TotalC2) & (TotalC2+C <= MaxR) & (AttackerMove==[IntermediateService1,TargetService,VulnType]) & (AttackerMove._not_in(AttackerMoves2)) & (AttackerMoves==AttackerMoves2+[AttackerMove]) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2))

#New above with credential
#attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,AttackerMoves2,TotalC2) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (P==P2+[IntermediateService1]) & (VulnType._in(E2)) & (E==E2+[VulnType]) & (TotalC==TotalC2) & (TotalC2+C <= MaxR) & (AttackerMove==[IntermediateService1,TargetService,VulnType]) & (AttackerMove._not_in(AttackerMoves2)) & (AttackerMoves==AttackerMoves2+[AttackerMove]) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & hasCredential(TargetService,X) & (X._not_in(E2)) & (E==E2+[X])
#& hasCredential(TargetService,Credential) # & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) 
#Inductive case to begin again at compromise point, no exploit necessary
#New: Added TargetService to E
attackPaths(SourceService,TargetService,P,E,AttackerMovesTotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,AttackerMoves2,TotalC2) & (P==P2+[IntermediateService1]) & compromised(TargetService) & (E==E2+[TargetService]) & (TotalC==TotalC2) & (TotalC2+C <= MaxR) & (AttackerMove==[IntermediateService1,TargetService,TargetService]) & (AttackerMove._not_in(AttackerMoves2)) & (AttackerMoves==AttackerMoves2+[AttackerMove]) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2))
#This removes loops: & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) 
 #& hasCredential(TargetService,Credential)  # & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & & isType(TargetService,ComponentType) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (VulnType._in(E2))

 #Inductive case to continue connectivity, using a credential captured earlier
 #Based on inductive case for using previously-used exploit
 # X == VulnType; TotalC2 <= MaxR
attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,AttackerMoves2,TotalC2) & cToWithPrivileges(IntermediateService1,TargetService,X,C) & usesCredential(TargetService,X) & (P==P2+[IntermediateService1]) & (X._in(E2)) & (E==E2+[X]) & (TotalC==TotalC2) & (TotalC2 <= MaxR) & (AttackerMove==[IntermediateService1,TargetService,X]) & (AttackerMove._not_in(AttackerMoves2)) & (AttackerMoves==AttackerMoves2+[AttackerMove]) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2))


#DELETE
#Inductive case to start new branch, no exploit because already compromised
#attackPaths(SourceService,TargetService,P,E,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,TotalC2) & compromised(TargetService) & (SourceService!=TargetService) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (E==E2+[]) & (TotalC==TotalC2) & (TotalC2+C <= MaxR) # cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService._not_in(P2))
#Inductive case to start new branch, no exploit because already in attack path
#attackPaths(SourceService,TargetService,P,E,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,TotalC2) & compromised(TargetService) & (SourceService!=TargetService) & (TargetService._in(P2)) & (P==P2+[IntermediateService1]) & (E==E2+[]) & (TotalC==TotalC2) & (TotalC2+C <= MaxR)




#Base case special case for first starting point
#attachPaths(Paths,Exploits,Cost)
#attackPaths([P],[],0) <= compromised(SourceService) & (P==[[SourceService],[]]) & P._not_in(Paths) & (Paths==[P])
#Base case special case for a subsequent starting points
#attackPaths(Paths,[],0) <= attackPaths(Paths2,[],TotalC) & compromised(SourceService) & (P==[[SourceService],[]]) & P._not_in(Paths2) & (Paths==Paths2+[P])
#Base case for extension of a single path 
#attackPaths(Paths,Exploits,TotalC) <= compromised(SourceService) & cToWithPrivileges(SourceService,TargetService,VulnType,TotalC) & (P==[[SourceService,TargetService],[VulnType]]) & (TotalC <= MaxR) & isType(TargetService,ComponentType) & P._not_in(Paths) & (Paths==[P])
#Inductive case, new exploit
#attackPaths(Paths,Exploits,TotalC) <= attackPaths(Paths2,Exploits2,TotalC2) & (P2._in(Paths2)) & (P2==) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (VulnType._not_in(E2)) & (E==E2+[VulnType]) & (TotalC==TotalC2+C) & (TotalC2+C <= MaxR) & isType(TargetService,ComponentType) 
#Inductive case, previously-used exploit
#attackPaths(SourceService,TargetService,P,E,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,TotalC2) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (VulnType._in(E2)) & (E==E2+[VulnType]) & (TotalC==TotalC2) & (TotalC2+C <= MaxR) & isType(TargetService,ComponentType)


#Thought: (E==E2+[VulnType,ComponentType]) & isType(IntermediateService1,ComponentType) #I need to not use isType in a subType manner elsewhere then?
#Add new supertype with cost
#Same type no new cost


#TODO: Refine this
#compromised(ServiceA) <= probCompromised(ServiceA,P)
compromised(TargetService) <= componentCompromisedWithAttributes(TargetService,P,CProvided,IProvided,AProvided)

#This is a connection across which an attacker can traverse
cToWithPrivileges(SourceService,TargetService,'legitimate',0) <= residesOn(SourceService,TargetService)
#cToWithPrivileges(SourceService,TargetService,'legitimate',0) <= connectsToWithPrivileges(SourceService,TargetService)
#TODO: attackerConnectsToWithPrivileges may no longer be necessary
cToWithPrivileges(SourceService,TargetService,VulnType,C) <= attackerConnectsToWithPrivileges(SourceService,TargetService,VulnType,C,CImpact,IImpact,AImpact)
attackerConnectsToWithPrivileges(SourceService,TargetService,Vulnerability,C,CImpact,IImpact,AImpact) <= connectsTo(SourceService,TargetService,CProvided,IProvided,AProvided) & isType(TargetService,ComponentType) & isVulnerable(ComponentType,Vulnerability,C,CImpact,IImpact,AImpact)

# This line is needed to make sure the cToWithPrivileges and 
# attackerConnectsToWithPrivileges rules above work
isType(TargetService,TargetService) <= usesCredential(TargetService,X)
# TODO: Expand usesCredential to include CImpact, etc. that's passed
# through to isVulnerable
# NOTE: 1,000,000 is chosen arbitrarily to be high
isVulnerable(TargetService,X,1000000,True,True,True) <= usesCredential(TargetService,X)

#If a service is in the path, the functions that require it are compromised
pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) & requires(FuncName,SourceService) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E])
#Above, including the sourceservice
pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) & requires(FuncName,TargetService) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E])
#Above, including the targetservice
pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) & ServiceA._in(P) & requires(FuncName,ServiceA) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E])
#pathCompromisesService(P,ServiceA) <= attackPaths(SourceService,TargetService,P,E,TotalC,MaxR) & (ServiceA._in(P))
#isPath(P) <= attackPaths(SourceService,TargetService,P,E,TotalC)
#path_compromises(P,FuncName) <= attackPaths(SourceService,TargetService,P,E,TotalC,MaxR) & ServiceA._in(P) & requires(FuncName,ServiceA)
#This is to include all compromised components, including those not on the path
#CHANGED TO REMOVE
#pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,TotalC) & compromised(OtherService) & requires(FuncName,OtherService) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E])
pathCompromisesFunctionWithCost(X,FuncName,Util,0) <= compromised(OtherService) & requires(FuncName,OtherService) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E])

#Path compromises a function if the attack path includes a service that is in the only viable path for the function's data flows consumption
#path is compromised if: 1. all consumption paths are compromised
# either by 1a: conflict with attack path
# or by 1b: a compromoised component already on attack path
#path is compromised if: 2. no consumption paths
#consumesPathNotCompromisedbyAttack(FuncName,TargetService,Data,DP,AP) <= consumesPath(FuncName,TargetService,Data,DP) & consumesData(FuncName,TargetService,Data,COK,CImpact,IOK,IImpact,AOK,AImpact) & attackPaths(SourceService,TargetService,AP,E,AttackerMoves,TotalC)
#pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) & consumesPath(FuncName,TargetService,Data,P2) & consumesData(FuncName,TargetService,Data,COK,CImpact,IOK,IImpact,AOK,AImpact) & pathsDontConflict(P,P2) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E]) #Do I need to do source and target service, too?
pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) & consumesData(FuncName,TargetService,Data,COK,CImpact,IOK,IImpact,AOK,AImpact) & (numConsumesPaths[FuncName,TargetService,Data] > numConsumesPaths[FuncName,TargetService,Data]) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E]) #Do I need to do source and target service, too?

#P is the Attack Path and 
#attackPathDoesntCompromiseFlow(P,FuncName,TargetService,Data) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) & consumesPath(FuncName,TargetService,Data,P2) & consumesData(FuncName,TargetService,Data,COK,CImpact,IOK,IImpact,AOK,AImpact) & (len_(list(set(P).intersection(set(P2)))) > 0)

consumesPathCompromised(FuncName,TargetService,Data,P2) <= consumesPath(FuncName,TargetService,Data,P2) & attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) & (ServiceA._in(P2)) & (ServiceA._in(P))
consumesPathCompromised(FuncName,TargetService,Data,P2) <= consumesPath(FuncName,TargetService,Data,P2) & attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) & (TargetService._in(P2))
consumesPathCompromised(FuncName,TargetService,Data,P2) <= consumesPath(FuncName,TargetService,Data,P2) & attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) & (SourceService._in(P2))

(numConsumesPaths[FuncName,TargetService,Data] == len_(P2)) <= consumesPath(FuncName,TargetService,Data,P2)
(numConsumesPathsCompromised[FuncName,TargetService,Data] == len_(P2)) <= consumesPathCompromised(FuncName,TargetService,Data,P2)
#(concatConsumesPathsCompromised[FuncName,TargetService,Data] == concat_([FuncName,TargetService,Data], order_by=FuncName, sep=',') <= consumesPath(FuncName,TargetService,Data,P2)

pathsConflict(P,P2) <= ServiceA._in(P) & ServiceA._in(P2)
pathsDontConflict(P,P2) <= ~pathsConflict(P,P2)


#There is no path that exists in consumesDataWithAttributes T/T/T for which an element of the attack path is in an element of the consumes path. Maybe do path doesn't compromise? By saying a path exists
#pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) & consumesDataWithAttributes(FunctionA,ServiceA,Data,True,CImpact,True,IImpact,True,AImpact,P2) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E]) 
#pathDoesntCompromiseFunctionWithCost() <= attackPaths(X,FuncName,Util,TotalC) & consumesDataWithAttributes(FunctionA,ServiceA,Data,True,CImpact,True,IImpact,True,AImpact,P2) & no elements of P2 are in P & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E]) 
#Do I need to do source and target service, too?
#pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) & consumesData(FuncName,ServiceA,Data,COK,CImpact,IOK,IImpact,AOK,AImpact) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E]) #Do I need to do source and target service, too?
#If we have a consumesData, then a function clearly requires it, right?
#pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) & consumesDataWithAttributesUnderAttack(FuncName,ServiceA,Data,COK,CImpact,False,IImpact,AOK,AImpact,DFP,P) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E]) #Do I need to do source and target service, too?
#pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) & consumesDataWithAttributesUnderAttack(FuncName,ServiceA,Data,COK,CImpact,IOK,IImpact,False,AImpact,DFP,P) #Do I need to do source and target service, too?
