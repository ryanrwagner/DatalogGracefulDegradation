#New codespace
#ASKED
#What is the worst case attack path for a given attacker capability?
#TotalC is the given attacker capability
#We find all the paths that exist for a given capability C that is <= TotalC
#Then we choose the max (worst)
(worstCasePath[TotalC] == max_(UtilPathPair, order_by=U)) <= pathCompromisesWithCost(X,C) & (pathCompromisesUtilities[X] == U) & (pathCompromisesFunctions[X] == FList) & (UtilPathPair==[U,FList,X]) & (TotalC >= C)

#BUG Fix this
MaxR=4

#ASKED
weightedWorstCasePath[TotalC] = probCapability[TotalC] * worstCasePathValue[TotalC]

#What are the paths that exist at a particular cost?
pathCompromisesWithCost(X,TotalC) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) & (X == [SourceService,TargetService,P,E])

#What's the value of the compromised functions for a path?
#Running sum would be helpful?
#(P[X]==sum_(Y, for_each=Z)) <= body
(pathCompromisesUtilities[X] == sum_(U2,for_each=X)) <= pathCompromisesFunctionWithCost(X,FuncName,U2,TotalC)

(pathCompromisesFunctions[X] == concat_(FuncName,order_by=FuncName,sep=',')) <= pathCompromisesFunctionWithCost(X,FuncName,U2,TotalC)

#Base case special case for no capability
#attackPaths(SourceService,SourceService,P,[],0) <= compromised(SourceService) & (P==[])
#Base case
#attackPaths(SourceService,TargetService,P,[VulnType],TotalC) <= compromised(SourceService) & cToWithPrivileges(SourceService,TargetService,VulnType,TotalC) & (P==[]) & (TotalC <= MaxR)
#Inductive case, new exploit
#attackPaths(SourceService,TargetService,P,E,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,TotalC2) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (VulnType._not_in(E2)) & (E==E2+[VulnType]) & (TotalC==TotalC2+C) & (TotalC2+C <= MaxR)
#Inductive case, previously-used exploit
#attackPaths(SourceService,TargetService,P,E,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,TotalC2) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (VulnType._in(E2)) & (E==E2+[VulnType]) & (TotalC==TotalC2) & (TotalC2+C <= MaxR)

#New Version for Types:
#Note, now each component must have an associated type
#Assumption that the attacker exploits specifically for the component type and not for a component super type
#Base case special case for no capability
#attackPaths(SourceService,SourceService,P,[],0) <= compromised(SourceService) & (P==[])
#Base case
#attackPaths(SourceService,TargetService,P,[VulnType],TotalC) <= compromised(SourceService) & cToWithPrivileges(SourceService,TargetService,VulnType,TotalC) & (P==[]) & (TotalC <= MaxR) & isType(TargetService,ComponentType)
#Inductive case, new exploit
#attackPaths(SourceService,TargetService,P,E,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,TotalC2) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (VulnType._not_in(E2)) & (E==E2+[VulnType]) & (TotalC==TotalC2+C) & (TotalC2+C <= MaxR) & isType(TargetService,ComponentType)
#Inductive case, previously-used exploit
#attackPaths(SourceService,TargetService,P,E,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,TotalC2) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (VulnType._in(E2)) & (E==E2+[VulnType]) & (TotalC==TotalC2) & (TotalC2+C <= MaxR) & isType(TargetService,ComponentType)


#New with Types and Branching
#Base case for first compromised component
attackPaths(SourceService,SourceService,P,[],AttackerMoves,0) <= compromised(SourceService) & (P==[]) & (AttackerMoves==[[SourceService,SourceService,'noExploit']]) #& hasCredentials(SourceService,Credentials)
#Base case to continue connectivity with first exploit
attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) <= compromised(SourceService) & cToWithPrivileges(SourceService,TargetService,VulnType,TotalC) & (P==[]) & (E==[VulnType]) & (TotalC <= MaxR) & isType(TargetService,ComponentType) & (AttackerMoves==[[SourceService,TargetService,VulnType]]) #& hasCredentials(TargetService,Credentials)
#Inductive case to continue connectivity, new exploit
attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,AttackerMoves2,TotalC2) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (P==P2+[IntermediateService1]) & (VulnType._not_in(E2)) & (E==E2+[VulnType]) & (TotalC==TotalC2+C) & (TotalC2+C <= MaxR) & (AttackerMove==[IntermediateService1,TargetService,VulnType]) & (AttackerMove._not_in(AttackerMoves2)) & (AttackerMoves==AttackerMoves2+[AttackerMove]) #& hasCredentials(TargetService,Credentials) # & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2))
#Inductive case to continue connectivity, previously-used exploit
attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,AttackerMoves2,TotalC2) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (P==P2+[IntermediateService1]) & (VulnType._in(E2)) & (E==E2+[VulnType]) & (TotalC==TotalC2) & (TotalC2+C <= MaxR) & (AttackerMove==[IntermediateService1,TargetService,VulnType]) & (AttackerMove._not_in(AttackerMoves2)) & (AttackerMoves==AttackerMoves2+[AttackerMove]) #& hasCredentials(TargetService,Credentials) # & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) 
#Inductive case to begin again at compromise point, no exploit necessary
attackPaths(SourceService,TargetService,P,E,AttackerMovesTotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,AttackerMoves2,TotalC2) & (P==P2+[IntermediateService1]) & compromised(TargetService) & (E==E2+[]) & (TotalC==TotalC2) & (TotalC2+C <= MaxR) & (AttackerMove==[IntermediateService1,TargetService,'noExploit']) & (AttackerMove._not_in(AttackerMoves2)) & (AttackerMoves==AttackerMoves2+[AttackerMove]) #& hasCredentials(TargetService,Credentials)  # & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & & isType(TargetService,ComponentType) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (VulnType._in(E2))


#DELETE
#Inductive case to start new branch, no exploit because already compromised
#attackPaths(SourceService,TargetService,P,E,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,TotalC2) & compromised(TargetService) & (SourceService!=TargetService) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (E==E2+[]) & (TotalC==TotalC2) & (TotalC2+C <= MaxR) # cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService._not_in(P2))
#Inductive case to start new branch, no exploit because already in attack path
#attackPaths(SourceService,TargetService,P,E,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,TotalC2) & compromised(TargetService) & (SourceService!=TargetService) & (TargetService._in(P2)) & (P==P2+[IntermediateService1]) & (E==E2+[]) & (TotalC==TotalC2) & (TotalC2+C <= MaxR)




#Base case special case for first starting point
#attachPaths(Paths,Exploits,Cost)
#attackPaths([P],[],0) <= compromised(SourceService) & (P==[[SourceService],[]]) & P._not_in(Paths) & (Paths==[P])
#Base case special case for a subsequent starting points
#attackPaths(Paths,[],0) <= attackPaths(Paths2,[],TotalC) & compromised(SourceService) & (P==[[SourceService],[]]) & P._not_in(Paths2) & (Paths==Paths2+[P])
#Base case for extension of a single path 
#attackPaths(Paths,Exploits,TotalC) <= compromised(SourceService) & cToWithPrivileges(SourceService,TargetService,VulnType,TotalC) & (P==[[SourceService,TargetService],[VulnType]]) & (TotalC <= MaxR) & isType(TargetService,ComponentType) & P._not_in(Paths) & (Paths==[P])
#Inductive case, new exploit
#attackPaths(Paths,Exploits,TotalC) <= attackPaths(Paths2,Exploits2,TotalC2) & (P2._in(Paths2)) & (P2==) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (VulnType._not_in(E2)) & (E==E2+[VulnType]) & (TotalC==TotalC2+C) & (TotalC2+C <= MaxR) & isType(TargetService,ComponentType) 
#Inductive case, previously-used exploit
#attackPaths(SourceService,TargetService,P,E,TotalC) <= attackPaths(SourceService,IntermediateService1,P2,E2,TotalC2) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (VulnType._in(E2)) & (E==E2+[VulnType]) & (TotalC==TotalC2) & (TotalC2+C <= MaxR) & isType(TargetService,ComponentType)


#Thought: (E==E2+[VulnType,ComponentType]) & isType(IntermediateService1,ComponentType) #I need to not use isType in a subType manner elsewhere then?
#Add new supertype with cost
#Same type no new cost


#TODO: Refine this
compromised(ServiceA) <= probCompromised(ServiceA,P)

#This is a connection across which an attacker can traverse
cToWithPrivileges(SourceService,TargetService,'legitimate',0) <= residesOn(SourceService,TargetService)
#cToWithPrivileges(SourceService,TargetService,'legitimate',0) <= connectsToWithPrivileges(SourceService,TargetService)
#TODO: attackerConnectsToWithPrivileges may no longer be necessary
cToWithPrivileges(SourceService,TargetService,VulnType,C) <= attackerConnectsToWithPrivileges(SourceService,TargetService,VulnType,C,CImpact,IImpact,AImpact,Credentials)
attackerConnectsToWithPrivileges(SourceService,TargetService,Vulnerability,C,CImpact,IImpact,AImpact,Credentials) <= connectsTo(SourceService,TargetService) & isType(TargetService,ComponentType) & isVulnerable(ComponentType,Vulnerability,C,CImpact,IImpact,AImpact,Credentials)

#If a service is in the path, the functions that require it are compromised
pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) & requires(FuncName,SourceService) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E])
#Above, including the sourceservice
pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) & requires(FuncName,TargetService) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E])
#Above, including the targetservice
pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) & ServiceA._in(P) & requires(FuncName,ServiceA) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E])
#pathCompromisesService(P,ServiceA) <= attackPaths(SourceService,TargetService,P,E,TotalC,MaxR) & (ServiceA._in(P))
#isPath(P) <= attackPaths(SourceService,TargetService,P,E,TotalC)
#path_compromises(P,FuncName) <= attackPaths(SourceService,TargetService,P,E,TotalC,MaxR) & ServiceA._in(P) & requires(FuncName,ServiceA)
#This is to include all compromised components, including those not on the path
#CHANGED TO REMOVE
#pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,TotalC) & compromised(OtherService) & requires(FuncName,OtherService) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E])
pathCompromisesFunctionWithCost(X,FuncName,Util,0) <= compromised(OtherService) & requires(FuncName,OtherService) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E])

#Path compromises a function if the attack path includes a service that is in the only viable path for the function's data flows consumption
#pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) & consumesData(FuncName,ServiceA,Data,True,CImpact,True,IImpact,True,AImpact) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E]) #Do I need to do source and target service, too?
#pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) & consumesData(FuncName,ServiceA,Data,COK,CImpact,IOK,IImpact,AOK,AImpact) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E]) #Do I need to do source and target service, too?
#If we have a consumesData, then a function clearly requires it, right?
pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) & consumesDataWithAttributesUnderAttack(FuncName,ServiceA,Data,COK,CImpact,False,IImpact,AOK,AImpact,DFP,P) & utility(FuncName,Util) & (X == [SourceService,TargetService,P,E]) #Do I need to do source and target service, too?
#pathCompromisesFunctionWithCost(X,FuncName,Util,TotalC) <= attackPaths(SourceService,TargetService,P,E,AttackerMoves,TotalC) & consumesDataWithAttributesUnderAttack(FuncName,ServiceA,Data,COK,CImpact,IOK,IImpact,False,AImpact,DFP,P) #Do I need to do source and target service, too?





#NOT USED. DEBUGGING


















#BUG Add in each combo of compromised components
#Fixed spelling here
(estimatedUtility[TotalC] == sum_(U,for_each=TotalC)) <= (U==weightedWorstCasePath[TotalC])
















#NOT USED. REMOVE








#This is new to handle specifically when we have a point of compromise on the system and
#it's isolated from the rest of the system
#if there's any path and something not in the path compromised, add the functionlity and utility

#P[X]==concat_(Y, order_by=Z, sep=',')) <= body
#(allCompromised[ServiceB]==concat_(ServiceA, key=ServiceA, sep=',')) <= compromised(ServiceA) & (ServiceB==True)
#(P[X]==tuple_(Y, order_by=Z)) <= body
(allCompromised[P]==tuple_(SourceService, order_by=SourceService)) <= compromised(SourceService)

#Inductive Case
#someCompromised(P) <= someCompromised(P2) & compromised(SourceService) & (SourceService._not_in(P2)) & (P==P2+[SourceService])
#Base Case
#someCompromised(P) <= compromised(SourceService) & (P==[SourceService])

#TODO: Is this necessary, or can I find these some other way?
#TODO: Base case should include compromised and build only from there?
allAttackerPathsCostPlus(SourceService,TargetService,P,E,F,U,TotalC,MaxR) <= allAttackerPathsCostPlus(SourceService,TargetService,P,E,F2,U2,TotalC,MaxR) & requires(FuncName,OtherService) & compromised(OtherService) & (FuncName._not_in(F2)) & (F==F2+[FuncName]) & utility(FuncName,Util) & (U == U2+Util)

#This is to include the functionality on the TargetService
allAttackerPathsCostPlus(SourceService,TargetService,P,E,F,U,TotalC,MaxR) <= allAttackerPathsCostPlus(SourceService,TargetService,P,E,F2,U2,TotalC,MaxR) & requires(FuncName,TargetService) & (FuncName._not_in(F2)) & (F==F2+[FuncName]) & utility(FuncName,Util) & (U == U2+Util)
#New to fix bug when compromise is in the source service for the base case
allAttackerPathsCostPlus(SourceService,TargetService,P,E,F,U,TotalC,MaxR) <= allAttackerPathsCostPlus(SourceService,TargetService,P,E,F2,U2,TotalC,MaxR) & requires(FuncName,SourceService) & (FuncName._not_in(F2)) & (F==F2+[FuncName]) & utility(FuncName,Util) & (U == U2+Util)
#This is the version for when the functionality F is already on the path
#NOTE? What if the component serves multiple functions? Does this work to add both?
#Perhaps remove the not seen before logic for being in the attack path and keep the not seen
#before logic for being an affected function
#Add utility mentions across and addtion...and make sure U, U2, Util is already defined
#NOTE? Make sure that, if an attack path goes through a path node with a zero cost path to another function, that other function is also questionable (e.g., superuser of a component with separate functionality)
# General inductive case with new intermediate service and affected functionality
#TODO Combine this and the below by using a lambda
#TODO Or maybe use an aggregate function to get all the paths
#allAttackerPathsCostPlus(SourceService,TargetService,P,E,F,U,TotalC,MaxR) <= allAttackerPathsCostPlus(SourceService,IntermediateService1,P2,E2,F2,U2,TotalC2,MaxR) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (E==E2+[VulnType]) & (TotalC==TotalC2+C) & (TotalC2+C <= MaxR) & requires(FuncName,IntermediateService1) & (F == (lambda F2, FuncName: (F2+[FuncName]) if FuncName._not_in(F2) else F2)) & utility(FuncName,Util) & (U == (lambda U2, Util, F2, FuncName: (U2+Util) if FuncName._not_in(F2) else U2)) & compromised(SourceService)

allAttackerPathsCostPlus(SourceService,TargetService,P,E,F,U,TotalC,MaxR) <= allAttackerPathsCostPlus(SourceService,IntermediateService1,P2,E2,F2,U2,TotalC2,MaxR) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (E==E2+[VulnType]) & (TotalC==TotalC2+C) & (TotalC2+C <= MaxR) & requires(FuncName,IntermediateService1) & (FuncName._not_in(F2)) & (F==F2+[FuncName]) & utility(FuncName,Util) & (U == U2+Util) & compromised(SourceService)
#Inductive case for when F has already been seen
allAttackerPathsCostPlus(SourceService,TargetService,P,E,F,U,TotalC,MaxR) <= allAttackerPathsCostPlus(SourceService,IntermediateService1,P2,E2,F2,U2,TotalC2,MaxR) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (E==E2+[VulnType]) & (TotalC==TotalC2+C) & (TotalC2+C <= MaxR) & requires(FuncName,IntermediateService1) & (FuncName._in(F2)) & (F==F2) & (U==U2) & compromised(SourceService)
#Inductive case when there are multiple functions for the intermediate service that has already been added to the path. Don't add anything to path, but add to function list and util affected
#NOTE? Should this instead/also apply to the base case?
allAttackerPathsCostPlus(SourceService,TargetService,P,E,F,U,TotalC,MaxR) <= allAttackerPathsCostPlus(SourceService,IntermediateService1,P2,E2,F2,U2,TotalC2,MaxR) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2) & (E==E2) & (TotalC==TotalC2) & (TotalC2 <= MaxR) & requires(FuncName,IntermediateService1) & (IntermediateService1._in(P2)) & (FuncName._not_in(F2)) & (F==F2+[FuncName]) & utility(FuncName,Util) & (U==U2+Util) & compromised(SourceService)
#Inductive case when there is other functionality that's already broken
#Changed from functionQuestionable to functionDown
allAttackerPathsCostPlus(SourceService,TargetService,P,E,F,U,TotalC,MaxR) <= allAttackerPathsCostPlus(SourceService,TargetService,P,E,F2,U2,TotalC,MaxR) & functionDown(FuncName,Util) & (FuncName._not_in(F2)) & (F==F2+[FuncName]) & utility(FuncName,Util) & (U==U2+Util)
#Base case
#NOTE: What if there's no affected functionality?
#NOTE? The sourceservice here is compromised, but the requires is for the target service...
allAttackerPathsCostPlus(SourceService,TargetService,P,[VulnType],[FuncName],Util,TotalC,MaxR) <= cToWithPrivileges(SourceService,TargetService,VulnType,TotalC) & (P==[]) & (TotalC <= MaxR) & requires(FuncName,TargetService) & utility(FuncName,Util) & compromised(SourceService)
#Base case for when there's no affected functionality
#allAttackerPathsCostPlus(SourceService,TargetService,P,[VulnType],F,Util,TotalC,MaxR) <= cToWithPrivileges(SourceService,TargetService,VulnType,TotalC) & (P==[]) & (TotalC <= MaxR) & functionalityFree(TargetService) & compromised(SourceService) & (F==[]) & (Util==0)

#This is new to handle specifically when we have a point of compromise on the system and
#it's isolated from the rest of the system
#if there's any path and something not in the path compromised, add the functionlity and utility
#TODO: Shouldn't this be in the base case?
allAttackerPathsCostPlus(SourceService,TargetService,P,E,F,U,TotalC,MaxR) <= allAttackerPathsCostPlus(SourceService,TargetService,P,E,F2,U2,TotalC,MaxR) & requires(FuncName,OtherService) & compromised(OtherService) & (FuncName._not_in(F2)) & (F==F2+[FuncName]) & utility(FuncName,Util) & (U == U2+Util)

#This is to include the functionality on the TargetService
allAttackerPathsCostPlus(SourceService,TargetService,P,E,F,U,TotalC,MaxR) <= allAttackerPathsCostPlus(SourceService,TargetService,P,E,F2,U2,TotalC,MaxR) & requires(FuncName,TargetService) & (FuncName._not_in(F2)) & (F==F2+[FuncName]) & utility(FuncName,Util) & (U == U2+Util)
#New to fix bug when compromise is in the source service for the base case
allAttackerPathsCostPlus(SourceService,TargetService,P,E,F,U,TotalC,MaxR) <= allAttackerPathsCostPlus(SourceService,TargetService,P,E,F2,U2,TotalC,MaxR) & requires(FuncName,SourceService) & (FuncName._not_in(F2)) & (F==F2+[FuncName]) & utility(FuncName,Util) & (U == U2+Util)
#This is the version for when the functionality F is already on the path
#NOTE? What if the component serves multiple functions? Does this work to add both?
#Perhaps remove the not seen before logic for being in the attack path and keep the not seen
#before logic for being an affected function
#Add utility mentions across and addtion...and make sure U, U2, Util is already defined
#NOTE? Make sure that, if an attack path goes through a path node with a zero cost path to another function, that other function is also questionable (e.g., superuser of a component with separate functionality)
# General inductive case with new intermediate service and affected functionality
allAttackerPathsCostPlus(SourceService,TargetService,P,E,F,U,TotalC,MaxR) <= allAttackerPathsCostPlus(SourceService,IntermediateService1,P2,E2,F2,U2,TotalC2,MaxR) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (E==E2+[VulnType]) & (TotalC==TotalC2+C) & (TotalC2+C <= MaxR) & requires(FuncName,IntermediateService1) & (FuncName._not_in(F2)) & (F==F2+[FuncName]) & utility(FuncName,Util) & (U == U2+Util) & compromised(SourceService)
#Inductive case for when F has already been seen
allAttackerPathsCostPlus(SourceService,TargetService,P,E,F,U,TotalC,MaxR) <= allAttackerPathsCostPlus(SourceService,IntermediateService1,P2,E2,F2,U2,TotalC2,MaxR) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (E==E2+[VulnType]) & (TotalC==TotalC2+C) & (TotalC2+C <= MaxR) & requires(FuncName,IntermediateService1) & (FuncName._in(F2)) & (F==F2) & (U==U2) & compromised(SourceService)
#Inductive case when there are multiple functions for the intermediate service that has already been added to the path. Don't add anything to path, but add to function list and util affected
#NOTE? Should this instead/also apply to the base case?
allAttackerPathsCostPlus(SourceService,TargetService,P,E,F,U,TotalC,MaxR) <= allAttackerPathsCostPlus(SourceService,IntermediateService1,P2,E2,F2,U2,TotalC2,MaxR) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2) & (E==E2) & (TotalC==TotalC2) & (TotalC2 <= MaxR) & requires(FuncName,IntermediateService1) & (IntermediateService1._in(P2)) & (FuncName._not_in(F2)) & (F==F2+[FuncName]) & utility(FuncName,Util) & (U==U2+Util) & compromised(SourceService)
#Inductive case when there is other functionality that's already broken
#Changed from functionQuestionable to functionDown
allAttackerPathsCostPlus(SourceService,TargetService,P,E,F,U,TotalC,MaxR) <= allAttackerPathsCostPlus(SourceService,TargetService,P,E,F2,U2,TotalC,MaxR) & functionDown(FuncName,Util) & (FuncName._not_in(F2)) & (F==F2+[FuncName]) & utility(FuncName,Util) & (U==U2+Util)
#Base case
#NOTE: What if there's no affected functionality?
#NOTE? The sourceservice here is compromised, but the requires is for the target service...
allAttackerPathsCostPlus(SourceService,TargetService,P,[VulnType],[FuncName],Util,TotalC,MaxR) <= cToWithPrivileges(SourceService,TargetService,VulnType,TotalC) & (P==[]) & (TotalC <= MaxR) & requires(FuncName,TargetService) & utility(FuncName,Util) & compromised(SourceService)
#Base case for when there's no affected functionality
#allAttackerPathsCostPlus(SourceService,TargetService,P,[VulnType],F,Util,TotalC,MaxR) <= cToWithPrivileges(SourceService,TargetService,VulnType,TotalC) & (P==[]) & (TotalC <= MaxR) & functionalityFree(TargetService) & compromised(SourceService) & (F==[]) & (Util==0)

#New logic. Hopefully better!
#BUG How do I not have to do this?
MaxR=4
#Get the worst case path at each cost
#Cost.in_(range(MaxR+1))
#riskDistribution = RiskPDF(dict([(0,0.20),(1,0.20),(2,0.20),(3,0.20),(4,0.20)]))
#probCapability[0] = 0.01
#probCapability[1] = 0.01
#probCapability[2] = 0.08
#probCapability[3] = 0.30
#probCapability[4] = 0.60

#(probCapability[C] == P) <= pC(C,P)






#How do I make a set of all the possible combinations of compromised components?
#First create an ordered linked list

#Base case
#compromisedOrderedList(Y) <=
#First in List
#firstCompromised(X) <= compromised(X) &
#Base case if only one is compromised


#Base case if none are compromised

#Then pull things off one by one
#One rule skips the component, the other adds the component

#Inductive case
#compromisedCombo(X) <= compromisedCombo(Y) & compromised(SourceService) & SourceService._not_in(Y) & (X==tuple(sorted(Y+[SourceService]))) #& ~setNotEquals(X,Z)
#Base case
#compromisedCombo(X) <= compromised(SourceService) & (X==[SourceService])

#setNotEquals(X,Y) <= Z._in(X) & Z._not_in(Y)
#setNotEquals(X,Y) <= Z._in(Y) & Z._not_in(X)


#What is the worst cast path at a particular cost?
#min_, max_ (P[X]==min_(Y, order_by=Z)) <= body : P[X] is the minimum (or maximum) of Y sorted by Z
#CHANGED
(worstCasePathValue[TotalC] == max_(U, order_by=U)) <= pathCompromisesWithCost(X,C) & (pathCompromisesUtilities[X] == U) & (pathCompromisesFunctions[X] == FList) & (TotalC >= C)
#(worstCasePathValue[TotalC] == max_(U, order_by=U)) <= pathCompromisesWithCost(X,TotalC) & (pathCompromisesUtilities[X] == U) & (pathCompromisesFunctions[X] == FList)

#CHANGED
(worstCasePathFromSource[SourceService,TotalC] == max_(UtilPathPair, order_by=U)) <= pathCompromisesWithCost(X,C) & (pathCompromisesUtilities[X] == U) & (pathCompromisesFunctions[X] == FList) & (UtilPathPair==[U,FList,X]) & (X==[SourceService,TargetService,P,E]) & (TotalC >= C) # & (X == [SourceService,TargetService,P,E]) & (SourceCost==[SourceService,TotalC])
#(worstCasePathFromSource[SourceService,TotalC] == max_(UtilPathPair, order_by=U)) <= pathCompromisesWithCost(X,TotalC) & (pathCompromisesUtilities[X] == U) & (pathCompromisesFunctions[X] == FList) & (UtilPathPair==[U,FList,X]) & (X==[SourceService,TargetService,P,E]) # & (X == [SourceService,TargetService,P,E]) & (SourceCost==[SourceService,TotalC])
#pathFromSourceWithCost(SourceService,CpathCompromisesWithCost(X,TotalC) & (pathCompromisesUtilities[X] == U) & (pathCompromisesFunctions[X] == FList) & (UtilPathPair==[U,FList,X]) & (X==[SourceService,TargetService,P,E])

#CHANGED

#(worstCasePath[TotalC] == max_(UtilPathPair, order_by=U)) <= pathCompromisesWithCost(X,TotalC) & (pathCompromisesUtilities[X] == U) & (pathCompromisesFunctions[X] == FList) & (UtilPathPair==[U,FList,X])
#worstCasePath(X,TotalC) <= pathCompromisesWithCost(X,TotalC) & (pathCompromisesUtilities[X] == U) & worstCasePath(Y,TotalC) &


#pathCompromisesWithCostObs(X,TotalC,PObs) <= attackPathsObs(SourceService,TargetService,P,E,TotalC,Obs) & (X == [SourceService,TargetService,P,E])



#P is attack path and P2 is flow path
#pathCompromisesFlowWithCost(X,FunctionA,ServiceA,Data,COK,CImpact,IOK,IImpact,AOK,AImpact,P) <= consumesDataWithAttributes(FunctionA,ServiceA,Data,COK,CImpact,IOK,IImpact,AOK,AImpact,P2)




#For Observations
#Base case special case for no capability
#attackPathsObs(SourceService,SourceService,P,[],0) <= compromised(SourceService) & (P==[])
#Base case
#attackPathsObs(SourceService,TargetService,P,[VulnType],TotalC) <= compromised(SourceService) & cToWithPrivileges(SourceService,TargetService,VulnType,TotalC) & (P==[]) & (TotalC <= MaxR)
#Inductive case
#attackPathsObs(SourceService,TargetService,P,E,TotalC) <= attackPathsObs(SourceService,IntermediateService1,P2,E2,TotalC2) & cToWithPrivileges(IntermediateService1,TargetService,VulnType,C) & (SourceService!=TargetService) & (SourceService._not_in(P2)) & (TargetService._not_in(P2)) & (P==P2+[IntermediateService1]) & (E==E2+[VulnType]) & (TotalC==TotalC2+C) & (TotalC2+C <= MaxR)





# Service is compromised if the host it resides on is compromised
compromised(TargetService) <= residesOn(TargetService,TargetHost) & compromised(TargetHost)

#FunctionA is questionable if it requires a connection that doesn't exist
functionDown(FunctionA,U) <= requiresConnection(FunctionA,SourceService,TargetService) & ~(transitiveConnects(SourceService,TargetService)) & utility(FunctionA,U)

transitiveConnectionBroken(SourceService,TargetService) <= requiresConnection(FunctionA,SourceService,TargetService) & ~(transitiveConnects(SourceService,TargetService))

#Backward compatibility
probCompromised(TargetService,P) <= componentCompromisedWithAttributes(TargetService,P,CProvided,IProvided,AProvided)

























#Vulnerabilities:

#+ localRootExploit('webServer')
#+ remoteRootExploit('attackerHost')
#+ remoteRootExploit('webServer')



#Remote user exploit is available if the service is running as user
#NEWCOMMENT attackerConnectsToWithPrivileges(SourceService,TargetService,'remoteUserExploit',C) <= remoteUserExploit(TargetService,C) & connectsTo(SourceService,TargetService)
#NEWCOMMENT vulnExists("remoteUserExploit",TargetService) <= remoteUserExploit(TargetService,C)
#NEWCOMMENT+ remoteUserExploit("TestA",0)

#Local root exploit is available if the service is running as user
#localRootExploit definition
#NEWCOMMENT attackerConnectsToWithPrivileges(ServiceA,TargetHost,'localRootExploit',C) <= residesOn(ServiceA,TargetHost) & localRootExploit(ServiceA,C)
#NEWCOMMENTvulnExists("localRootExploit",TargetService) <= localRootExploit(TargetService,C)
#NEWCOMMENT+ localRootExploit("TestA",0)











#Remote root exploit is available if the service is running as root and there is another service on the same host running as user
#remoteRootExploit definition
#Old
#NEWCOMMENT attackerConnectsToWithPrivileges(ServiceA,HostB,'remoteRootExploit',C) <= remoteRootExploit(HostB,C) & residesOn(ServiceB,HostB) & connectsTo(ServiceA,ServiceB)
#New
#NEWCOMMENT attackerConnectsToWithPrivileges(ServiceA,HostB,'remoteRootExploit',C) <= remoteRootExploitWithAttributes(HostB,C,Confidentiality,Integrity,Availability) & residesOn(ServiceB,HostB) & connectsTo(ServiceA,ServiceB)
#Note: There should be a way to say the attacker connects from service A VIA service B to superuser B so it's clear turning off B will cut the connection. This one above is not entirely accurtate. Maybe this isn't an issue because the vulnerability is in the OS and not the service?
v#NEWCOMMENT ulnExists("remoteRootExploit",TargetService) <= remoteRootExploit(TargetService,C)
#NEWCOMMENT + remoteRootExploit("TestA",0)
#NEWCOMMENT vulnExistsWithAttributes("remoteRootExploit",TargetService,Confidentiality,Integrity,Availability) <= remoteRootExploitWithAttributes(TargetService,C,Confidentiality,Integrity,Availability)
#NEWCOMMENT + remoteRootExploitWithAttributes("TestA",0,False,False,False)

#localUserExploit definition
#remoteUserExploit definition




####Not using the below code


# COMPROMISE LOGIC
